<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
         "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<script type="text/javascript"
  src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<title>GAP (RightQuasigroups) - Chapter 11: Racks and quandles</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8" />
<meta name="generator" content="GAPDoc2HTML" />
<link rel="stylesheet" type="text/css" href="manual.css" />
<script src="manual.js" type="text/javascript"></script>
<script type="text/javascript">overwriteStyle();</script>
</head>
<body class="chap11"  onload="jscontent()">


<div class="chlinktop"><span class="chlink1">Goto Chapter: </span><a href="chap0_mj.html">Top</a>  <a href="chap1_mj.html">1</a>  <a href="chap2_mj.html">2</a>  <a href="chap3_mj.html">3</a>  <a href="chap4_mj.html">4</a>  <a href="chap5_mj.html">5</a>  <a href="chap6_mj.html">6</a>  <a href="chap7_mj.html">7</a>  <a href="chap8_mj.html">8</a>  <a href="chap9_mj.html">9</a>  <a href="chap10_mj.html">10</a>  <a href="chap11_mj.html">11</a>  <a href="chap12_mj.html">12</a>  <a href="chapBib_mj.html">Bib</a>  <a href="chapInd_mj.html">Ind</a>  </div>

<div class="chlinkprevnexttop">&nbsp;<a href="chap0_mj.html">[Top of Book]</a>&nbsp;  <a href="chap0_mj.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap10_mj.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chap12_mj.html">[Next Chapter]</a>&nbsp;  </div>

<p id="mathjaxlink" class="pcenter"><a href="chap11.html">[MathJax off]</a></p>
<p><a id="X79FBC1F2864C28EB" name="X79FBC1F2864C28EB"></a></p>
<div class="ChapSects"><a href="chap11_mj.html#X79FBC1F2864C28EB">11 <span class="Heading">Racks and quandles</span></a>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap11_mj.html#X82725F6E7828D473">11.1 <span class="Heading">Testing properties of racks and quandles</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap11_mj.html#X7E50B20E85D6ED8A">11.1-1 <span class="Heading">IsRack and IsQuandle</span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap11_mj.html#X87F3279F874F6A1D">11.1-2 <span class="Heading">IsHomogeneousRack and IsHomogeneousQuandle</span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap11_mj.html#X7AB8029F81723378">11.1-3 <span class="Heading">IsConnectedRack and IsConnectedQuandle</span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap11_mj.html#X791EB74C7D64E695">11.1-4 <span class="Heading">IsLatinRack and IsLatinQuandle</span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap11_mj.html#X8617805E7A6593CB">11.1-5 <span class="Heading">IsProjectionRack and IsProjectionQuandle</span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap11_mj.html#X7A1F435882501269">11.1-6 <span class="Heading">IsPermutationalRack and IsPermutationalQuandle</span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap11_mj.html#X83499C277D169EB4">11.1-7 <span class="Heading">IsFaithfulRack and IsFaithfulQuandle</span></a>
</span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap11_mj.html#X790E0C0F7AF82839">11.2 <span class="Heading">Constructors for racks</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap11_mj.html#X870756E379474906">11.2-1 PermutationalRack</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap11_mj.html#X87BF8D3A83C980C8">11.2-2 CyclicRack</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap11_mj.html#X7B50D2297EA13A72">11.2-3 IsAffineRackArithmeticForm</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap11_mj.html#X87359C5384312CB0">11.2-4 AffineRack</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap11_mj.html#X81B873537BF7215B">11.3 <span class="Heading">Constructors for quandles</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap11_mj.html#X83929C8979472E1E">11.3-1 IsAffineQuandleArithmeticForm</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap11_mj.html#X7D07F3FF80114B44">11.3-2 AffineQuandle</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap11_mj.html#X85672B5080B5D262">11.3-3 DihedralQuandle</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap11_mj.html#X84309A5B7DF5760D">11.3-4 CoreOfGroup</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap11_mj.html#X7A27EED18304A01E">11.3-5 CoreOfRightBolLoop</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap11_mj.html#X7C8633967D92F9EA">11.3-6 <span class="Heading">GalkinQuandle and HomogeneousQuandle</span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap11_mj.html#X82013FC97875ADBC">11.3-7 ConjugationQuandle</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap11_mj.html#X862B9AF9843AA023">11.4 <span class="Heading">Rack envelopes and quandle envelopes: The Joyce-Blackburn representation</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap11_mj.html#X841A4D657F2D0AE2">11.4-1 <span class="Heading">IsRackEnvelope and IsQuandleEnvelope</span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap11_mj.html#X7D200C2D83FE158D">11.4-2 <span class="Heading">RackEnvelope and QuandleEnvelope</span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap11_mj.html#X81F0417D7EA5504B">11.4-3 RackByRackEnvelope</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap11_mj.html#X8440413D8146C267">11.5 <span class="Heading">Subracks and subquandles</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap11_mj.html#X7EACDAF081352D14">11.5-1 <span class="Heading">Testing subracks and subquandles</span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap11_mj.html#X7E879779877E2A39">11.5-2 <span class="Heading">Creating subracks and subquandles</span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap11_mj.html#X7A34F665876B0F53">11.5-3 <span class="Heading">All subracks and subquandles</span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap11_mj.html#X80773F578384A0CF">11.5-4 <span class="Heading">Racks and quandles by generators</span></a>
</span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap11_mj.html#X7B2647047A89F64B">11.6 <span class="Heading">Isomorphisms and isotopisms of racks and quandles</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap11_mj.html#X86082383814A82A5">11.6-1 <span class="Heading">IsomorphismRacks, IsomorphismQuandles</span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap11_mj.html#X7C45E9B67C1BB14D">11.6-2 <span class="Heading">Racks and quandles up to isomorphism</span></a>
</span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap11_mj.html#X7F53D3F18465885F">11.7 <span class="Heading">Groups associated with racks and quandles</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap11_mj.html#X79A9BF8A84FC4590">11.7-1 AdjointGroup</a></span>
</div></div>
</div>

<h3>11 <span class="Heading">Racks and quandles</span></h3>

<p>A <em>rack</em> is a right quasigroup satisfying the right self-distributive law <span class="SimpleMath">\((x*y)*z = (x*z)*(y*z)\)</span>. A <em>quandle</em> is an idempotent rack.</p>

<p>A rack <span class="SimpleMath">\(Q\)</span> is <em>homogeneous</em> if its automorphism group acts transitively on <span class="SimpleMath">\(Q\)</span>.</p>

<p>A rack <span class="SimpleMath">\(Q\)</span> is <em>connected</em> if its right multiplication group acts transitively on <span class="SimpleMath">\(Q\)</span>.</p>

<p>A rack is <em>latin</em> if it is a quasigroup. A latin rack is automatically a (latin) quandle.</p>

<p>A latin rack is connected and a connected rack is homogeneous.</p>

<p>Constructors of <strong class="pkg">RightQuasigroups</strong> declare racks and quandles as right quasigroups or, in the latin case, as quasigroups. If a rack/quandle is declared as a right quasigroup, it is displayed as <code class="code">&lt;rack...&gt;</code> or <code class="code">&lt;quandle...&gt;</code>, while if it is declared as a quasigroup, it is displayed as <code class="code">&lt;latin rack...&gt;</code> or <code class="code">&lt;latin quandle...&gt;</code>.</p>

<p><a id="X82725F6E7828D473" name="X82725F6E7828D473"></a></p>

<h4>11.1 <span class="Heading">Testing properties of racks and quandles</span></h4>

<p><a id="X7E50B20E85D6ED8A" name="X7E50B20E85D6ED8A"></a></p>

<h5>11.1-1 <span class="Heading">IsRack and IsQuandle</span></h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsRack</code>( <var class="Arg">Q</var> )</td><td class="tdright">(&nbsp;property&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsQuandle</code>( <var class="Arg">Q</var> )</td><td class="tdright">(&nbsp;property&nbsp;)</td></tr></table></div>
<p>Returns: <code class="code">true</code> if the right quasigroup <var class="Arg">Q</var> is a rack/quandle, else returns <code class="code">false</code>.</p>

<p><a id="X87F3279F874F6A1D" name="X87F3279F874F6A1D"></a></p>

<h5>11.1-2 <span class="Heading">IsHomogeneousRack and IsHomogeneousQuandle</span></h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsHomogeneousRack</code>( <var class="Arg">Q</var> )</td><td class="tdright">(&nbsp;property&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsHomogeneousQuandle</code>( <var class="Arg">Q</var> )</td><td class="tdright">(&nbsp;property&nbsp;)</td></tr></table></div>
<p>Returns: <code class="code">true</code> if the right quasigroup <var class="Arg">Q</var> is a homogeneous rack/quandle, that is, a rack/quandle on which the automorphism group acts transitively.</p>

<p><a id="X7AB8029F81723378" name="X7AB8029F81723378"></a></p>

<h5>11.1-3 <span class="Heading">IsConnectedRack and IsConnectedQuandle</span></h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsConnectedRack</code>( <var class="Arg">Q</var> )</td><td class="tdright">(&nbsp;property&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsConnectedQuandle</code>( <var class="Arg">Q</var> )</td><td class="tdright">(&nbsp;property&nbsp;)</td></tr></table></div>
<p>Returns: <code class="code">true</code> if the right quasigroup <var class="Arg">Q</var> is a connected rack/quandle, that is, a rack/quandle on which the right multiplication group acts transitively.</p>

<p><a id="X791EB74C7D64E695" name="X791EB74C7D64E695"></a></p>

<h5>11.1-4 <span class="Heading">IsLatinRack and IsLatinQuandle</span></h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsLatinRack</code>( <var class="Arg">Q</var> )</td><td class="tdright">(&nbsp;property&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsLatinQuandle</code>( <var class="Arg">Q</var> )</td><td class="tdright">(&nbsp;property&nbsp;)</td></tr></table></div>
<p>Returns: <code class="code">true</code> if the right quasigroup <var class="Arg">Q</var> is a latin rack/quandle, else returns <code class="code">false</code>.</p>

<p><a id="X8617805E7A6593CB" name="X8617805E7A6593CB"></a></p>

<h5>11.1-5 <span class="Heading">IsProjectionRack and IsProjectionQuandle</span></h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsProjectionRack</code>( <var class="Arg">Q</var> )</td><td class="tdright">(&nbsp;property&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsProjectionQuandle</code>( <var class="Arg">Q</var> )</td><td class="tdright">(&nbsp;property&nbsp;)</td></tr></table></div>
<p>Returns: <code class="code">true</code> if the right quasigroup <var class="Arg">Q</var> is a projection rack/quandle, that is, a rack/quandle satisfying <span class="SimpleMath">\(x*y=x\)</span>.</p>

<p><a id="X7A1F435882501269" name="X7A1F435882501269"></a></p>

<h5>11.1-6 <span class="Heading">IsPermutationalRack and IsPermutationalQuandle</span></h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsPermutationalRack</code>( <var class="Arg">Q</var> )</td><td class="tdright">(&nbsp;property&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsPermutationalQuandle</code>( <var class="Arg">Q</var> )</td><td class="tdright">(&nbsp;property&nbsp;)</td></tr></table></div>
<p>Returns: <code class="code">true</code> if the right quasigroup <var class="Arg">Q</var> is a permutational rack/quandle, that is, a rack/quandle satisfying <span class="SimpleMath">\(x*y=f(x)\)</span> for some permutation <span class="SimpleMath">\(f\)</span> of <var class="Arg">Q</var>.</p>

<p><a id="X83499C277D169EB4" name="X83499C277D169EB4"></a></p>

<h5>11.1-7 <span class="Heading">IsFaithfulRack and IsFaithfulQuandle</span></h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsFaithfulRack</code>( <var class="Arg">Q</var> )</td><td class="tdright">(&nbsp;property&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsFaithfulQuandle</code>( <var class="Arg">Q</var> )</td><td class="tdright">(&nbsp;property&nbsp;)</td></tr></table></div>
<p>Returns: <code class="code">true</code> if the right quasigroup <var class="Arg">Q</var> is a faithful rack/quandle, that is, a rack/quandle with <span class="SimpleMath">\(x\mapsto R_x\)</span> injective on <var class="Arg">Q</var>.</p>

<p><a id="X790E0C0F7AF82839" name="X790E0C0F7AF82839"></a></p>

<h4>11.2 <span class="Heading">Constructors for racks</span></h4>

<p>The projection right quasigroup is automatically a quandle. We support <code class="code">ProjectionRack</code> and <code class="code">ProjectionQuandle</code> as a synonym of <code class="code">ProjectionRightQuasigroup</code>.</p>

<p><a id="X870756E379474906" name="X870756E379474906"></a></p>

<h5>11.2-1 PermutationalRack</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PermutationalRack</code>( <var class="Arg">n</var>, <var class="Arg">f</var>[, <var class="Arg">constructorStyle</var>] )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: the permutational rack on <code class="code">[1..</code><var class="Arg">n</var><code class="code">]</code> via the permutation <var class="Arg">f</var>, that is, the rack on <code class="code">[1..</code><var class="Arg">n</var><code class="code">]</code> with multiplication <code class="code">x*y = x^f</code>. The permutation <var class="Arg">f</var> must restrict to <code class="code">[1..</code><var class="Arg">n</var><code class="code">]</code>.</p>

<p>Note that for index based right quasigroups it is possible to change the underlying set via <code class="code">ChangeUnderlyingSet</code>, cf. Section <a href="chap1_mj.html#X7B36037780974644"><span class="RefLink">1.4</span></a>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PermutationalRack( 10, (3,4,5) );</span>
&lt;rack of size 10&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Q := PermutationalRack( 100000, (1,100000), ConstructorStyle( false, true ) );</span>
&lt;rack of size 100000&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Q[1]*Q[2];</span>
r100000
</pre></div>

<p><a id="X87BF8D3A83C980C8" name="X87BF8D3A83C980C8"></a></p>

<h5>11.2-2 CyclicRack</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CyclicRack</code>( <var class="Arg">n</var>[, <var class="Arg">constructorStyle</var>] )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: the cyclic rack on <code class="code">[1..</code><var class="Arg">n</var><code class="code">]</code>, that is, the rack on <code class="code">[1..</code><var class="Arg">n</var><code class="code">]</code> with multiplication <code class="code">x*y = x+1</code>, where the addition is with wraparound. This is the same as permutational rack via the <var class="Arg">n</var>-cycle <code class="code">(1,2,...,</code><var class="Arg">n</var><code class="code">)</code>.</p>

<p>A rack is <em>affine</em> if it is an affine right quasigroup over an abelian group (that happens to be a rack). See Section <a href="chap9_mj.html#X8635F739800C7CFD"><span class="RefLink">9.4</span></a> for affine right quasigroups and their arithmetic forms. For affine racks, we allow only arithmetic forms <code class="code">(n,f,g,c)</code>, <code class="code">(F,f,g,c)</code> and <code class="code">(G,f,g,c)</code>.</p>

<p>If <span class="SimpleMath">\(G\)</span> is an (additive) abelian group, <span class="SimpleMath">\(f\)</span> an automorphism of <span class="SimpleMath">\(G\)</span>, <span class="SimpleMath">\(g\)</span> an endomorphism of <span class="SimpleMath">\(G\)</span> and <span class="SimpleMath">\(c\in G\)</span>, then the affine right quasigroup on <span class="SimpleMath">\(G\)</span> with arithmetic form <span class="SimpleMath">\((G,f,g,c)\)</span> and multiplication <span class="SimpleMath">\(x*y = f(x)+g(y)+c\)</span> is a rack iff <span class="SimpleMath">\(g(c)=0\)</span>, <span class="SimpleMath">\(fg = gf\)</span> and <span class="SimpleMath">\(g(f+g-I)\)</span> is the zero mapping, where <span class="SimpleMath">\(I\)</span> is the identity mapping on <span class="SimpleMath">\(G\)</span>.</p>

<p>In particular, if <span class="SimpleMath">\(n\)</span> is a positive integer, <span class="SimpleMath">\(f\)</span> is an integer relatively prime to <span class="SimpleMath">\(n\)</span>, and <span class="SimpleMath">\(g\)</span>, <span class="SimpleMath">\(c\)</span> are integers, then the affine right quasigroup on <span class="SimpleMath">\([0..n-1]\)</span> with arithmetic form <span class="SimpleMath">\((n,f,g,c)\)</span> and multiplication <span class="SimpleMath">\(x*y = (f*x+g*y+c)\ \mathrm{mod}\ n\)</span> is a rack iff <span class="SimpleMath">\(gc\equiv 0\pmod n\)</span> and <span class="SimpleMath">\(g(f+g-1)\equiv 0\pmod n\)</span>.</p>

<p><a id="X7B50D2297EA13A72" name="X7B50D2297EA13A72"></a></p>

<h5>11.2-3 IsAffineRackArithmeticForm</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsAffineRackArithmeticForm</code>( <var class="Arg">arg</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: <code class="code">true</code> if <var class="Arg">arg</var> is an arithmetic form of an affine rack. See above for allowed arithmetic forms.</p>

<p><a id="X87359C5384312CB0" name="X87359C5384312CB0"></a></p>

<h5>11.2-4 AffineRack</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; AffineRack</code>( <var class="Arg">arg</var>[, <var class="Arg">constructorStyle</var>] )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns: the affine rack with arithmetic form <var class="Arg">arg</var>. See above for allowed arithmetic forms.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"># affine rack on [0..11]</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">[ IsAffineRackArithmeticForm( 12, 5, 2, 6 ), AffineRack( 12, 5, 2, 6 ) ];</span>
[ true, &lt;rack of size 12&gt; ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"># affine rack on GF(9)</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">F := GF(9);; f := 2*Z(9);; g := Z(9)+One(F);; c := Zero(F);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">[ IsAffineRackArithmeticForm( F, f, g, c ), AffineRack( F, f, g, c ) ]; # latin racks are quandles</span>
[ true, &lt;latin quandle of size 9&gt; ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"># affine rack on cyclic group of order 4</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">x := (1,2,3,4);; G := Group( x );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">f := GroupHomomorphismByImages( G, G, [x], [x^-1] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g := GroupHomomorphismByImages( G, G, [x], [x^2] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">c := x^2;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">[ IsAffineRackArithmeticForm( G, f, g, c ), AffineRack( G, f, g, c ) ];</span>
[ true, &lt;rack of size 4&gt; ]
</pre></div>

<p><a id="X81B873537BF7215B" name="X81B873537BF7215B"></a></p>

<h4>11.3 <span class="Heading">Constructors for quandles</span></h4>

<p>A quandle is <em>affine</em> if it is an affine right quasigroup over an abelian group (that happens to be a quandle). See Section <a href="chap9_mj.html#X8635F739800C7CFD"><span class="RefLink">9.4</span></a> for affine right quasigroups and their arithmetic forms.</p>

<p>If <span class="SimpleMath">\(G\)</span> is an (additive) abelian group, <span class="SimpleMath">\(f\)</span> an automorphism of <span class="SimpleMath">\(G\)</span>, <span class="SimpleMath">\(g\)</span> an endomorphism of <span class="SimpleMath">\(G\)</span> and <span class="SimpleMath">\(c\in G\)</span>, then the affine right quasigroup on <span class="SimpleMath">\(G\)</span> with arithmetic form <span class="SimpleMath">\((G,f,g,c)\)</span> and multiplication <span class="SimpleMath">\(x*y = f(x)+g(y)+c\)</span> is a quandle iff <span class="SimpleMath">\(c=0\)</span> and <span class="SimpleMath">\(g=I-f\)</span>, where <span class="SimpleMath">\(I\)</span> is the identity mapping on <span class="SimpleMath">\(G\)</span>. Therefore, for affine quandles, we allow only "shortened" arithmetic forms <code class="code">(n,f)</code>, <code class="code">(F,f)</code> and <code class="code">(G,f)</code>.</p>

<p><a id="X83929C8979472E1E" name="X83929C8979472E1E"></a></p>

<h5>11.3-1 IsAffineQuandleArithmeticForm</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsAffineQuandleArithmeticForm</code>( <var class="Arg">arg</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: <code class="code">true</code> if <var class="Arg">arg</var> is an arithmetic form of an affine quandle. See above for allowed arithmetic forms.</p>

<p><a id="X7D07F3FF80114B44" name="X7D07F3FF80114B44"></a></p>

<h5>11.3-2 AffineQuandle</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; AffineQuandle</code>( <var class="Arg">arg</var>[, <var class="Arg">constructorStyle</var>] )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns: the affine quande with arithmetic form <var class="Arg">arg</var>. See above for allowed arithmetic forms. The synonym <code class="code">AlexanderQuandle</code> is also supported.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"># affine quandle on [0..9]</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">[ IsAffineQuandleArithmeticForm( 10, 3 ), AffineQuandle( 10, 3 ) ];</span>
[ true, &lt;quandle of size 10&gt; ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"># affine quandle on GF(9)</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">[ IsAffineQuandleArithmeticForm( GF(9), 2*Z(9) ), AffineQuandle( GF(9), 2*Z(9) ) ];</span>
[ true, &lt;latin quandle of size 9&gt; ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"># affine quandle on cyclic group of order 5</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G := CyclicGroup(5);; f := Elements( AutomorphismGroup( G ) )[2];</span>
[ f1 ] -&gt; [ f1^2 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">[ IsAffineQuandleArithmeticForm( G, f ), AffineQuandle( G, f ) ];</span>
[ true, &lt;latin quandle of size 5&gt; ]
</pre></div>

<p><a id="X85672B5080B5D262" name="X85672B5080B5D262"></a></p>

<h5>11.3-3 DihedralQuandle</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DihedralQuandle</code>( <var class="Arg">n</var>[, <var class="Arg">constructorstyle</var>] )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: the dihedral quandle of size <var class="Arg">n</var>, that is, the quandle on <code class="code">[0..</code><var class="Arg">n</var><code class="code">-1]</code> with multiplication <code class="code">x*y = (-x+2y) mod </code><var class="Arg">n</var>.</p>

<p><a id="X84309A5B7DF5760D" name="X84309A5B7DF5760D"></a></p>

<h5>11.3-4 CoreOfGroup</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CoreOfGroup</code>( <var class="Arg">G</var>[, <var class="Arg">constructorStyle</var>] )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: the core of the group (resp. additive group) <var class="Arg">G</var> defined by <span class="SimpleMath">\(x*y = (yx^{-1})y\)</span> (resp. <span class="SimpleMath">\(x*y=y-x+y\)</span>). The core is always a quandle.</p>

<p>Note: The value of <code class="code">constructorStyle.checkArguments</code> of the optional argument <code class="code">constructorStyle</code> does not come into play and need not be specified.</p>

<p><a id="X7A27EED18304A01E" name="X7A27EED18304A01E"></a></p>

<h5>11.3-5 CoreOfRightBolLoop</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CoreOfRightBolLoop</code>( <var class="Arg">Q</var>[, <var class="Arg">constructorStyle</var>] )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: the core of the right Bol loop <var class="Arg">Q</var> defined by <span class="SimpleMath">\(x*y = (yx^{-1})y\)</span>. The core is always a quandle.</p>

<p>Note: The value of <code class="code">constructorStyle.checkArguments</code> of the optional argument <code class="code">constructorStyle</code> does not come into play and need not be specified.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G := AlternatingGroup( 5 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Q := CoreOfGroup( G );</span>
&lt;quandle of size 60&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Q[(1,2,3)]*Q[(1,2,3,4,5)] = Q[(1,2,3)*(1,2,3,4,5)^(-1)*(1,2,3)];</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CoreOfRightBolLoop( RightBolLoop(8,1) );</span>
&lt;quandle of size 8&gt;
</pre></div>

<p>Given a group <span class="SimpleMath">\(G\)</span>, subgroup <span class="SimpleMath">\(H\)</span> and an automorphism <span class="SimpleMath">\(f\)</span> of <span class="SimpleMath">\(G\)</span> that centralizes <span class="SimpleMath">\(H\)</span>, the <em>Galkin quandle</em> (aka <em>coset quandle</em> or <em>homogeneous quandle</em>) is defined on the right cosets <span class="SimpleMath">\(\{Hx:x\in G\}\)</span> by <span class="SimpleMath">\(Hx*Hy = H f(xy^{-1})y\)</span>.</p>

<p><a id="X7C8633967D92F9EA" name="X7C8633967D92F9EA"></a></p>

<h5>11.3-6 <span class="Heading">GalkinQuandle and HomogeneousQuandle</span></h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; GalkinQuandle</code>( <var class="Arg">G</var>, <var class="Arg">H</var>, <var class="Arg">f</var>[, <var class="Arg">constructorStyle</var>] )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: the Galkin quandle constructed from the group <var class="Arg">G</var>, subgroup <var class="Arg">H</var> and automorphism <var class="Arg">f</var> of <var class="Arg">G</var> that centralizes <var class="Arg">H</var>. The synonym <code class="code">HomogeneousQuandle</code> is also supported.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G := SymmetricGroup( 4 );; H := Subgroup( G, [(1,2)] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">f := Filtered( AutomorphismGroup( G ), g -&gt; (1,2)^g = (1,2) )[3];</span>
^(3,4)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Q := GalkinQuandle( G, H, f );</span>
&lt;quandle of size 12&gt;
</pre></div>

<p><a id="X82013FC97875ADBC" name="X82013FC97875ADBC"></a></p>

<h5>11.3-7 ConjugationQuandle</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ConjugationQuandle</code>( <var class="Arg">G</var>[, <var class="Arg">m</var>[, <var class="Arg">constructorStyle</var>]] )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns: the conjugation quandle on <var class="Arg">G</var> defined by <span class="SimpleMath">\(x*y = y^{-m}*x*y^m\)</span>. The argument <var class="Arg">G</var> can either be a group or a collection of group elements closed under the above operation. If the optional argument <var class="Arg">m</var> is omitted, the multiplication is given by <span class="SimpleMath">\(x*y=y^{-1}*x*y\)</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G := SymmetricGroup( 3 );; </span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ConjugationQuandle( G ); # y^-1*x*y on G</span>
&lt;quandle of size 6&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ConjugationQuandle( ConjugacyClass( G, (1,2,3) ) ); # y^-1*x*y on [ (1,2,3), (1,3,2) ]</span>
&lt;quandle of size 2&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ConjugationQuandle( G, 2 ); # y^-2*x*y^2 on G</span>
&lt;quandle of size 6&gt;
</pre></div>

<p><a id="X862B9AF9843AA023" name="X862B9AF9843AA023"></a></p>

<h4>11.4 <span class="Heading">Rack envelopes and quandle envelopes: The Joyce-Blackburn representation</span></h4>

<p>The triple <span class="SimpleMath">\((G,S,R)\)</span> is a <em>rack envelope</em> if <span class="SimpleMath">\(G\)</span> is a (permutation) group, <span class="SimpleMath">\(S\)</span> is a set of orbit representatives of <span class="SimpleMath">\(G\)</span>, and <span class="SimpleMath">\(R=(r_x:x\in S)\)</span> is a collection of elements of <span class="SimpleMath">\(G\)</span> such that <span class="SimpleMath">\(r_x\in C_G(G_x)\)</span> for every <span class="SimpleMath">\(x\in S\)</span>, and <span class="SimpleMath">\(\langle \bigcup_{x\in S}r_x^G\rangle = G\)</span>. Here <span class="SimpleMath">\(r_x^G\)</span> is the conjugacy class of <span class="SimpleMath">\(r_x\)</span> in <span class="SimpleMath">\(G\)</span>.</p>

<p>The triple <span class="SimpleMath">\((G,S,R)\)</span> is a <em>quandle envelope</em> if it is a rack envelope and <span class="SimpleMath">\(r_x(x)=x\)</span> (that is, <span class="SimpleMath">\(r_x\in Z(G_x)\)</span>) for every <span class="SimpleMath">\(x\in S\)</span>.</p>

<p>There is a one-to-one correspondence between racks (quandles) and rack envelopes (quandle envelopes) on a given set. This is sometimes called the <em>Joyce-Blackburn representation</em> of racks (quandles). Given a rack/quandle <span class="SimpleMath">\((Q,\cdot)\)</span>, let <span class="SimpleMath">\(G=\mathrm{Mlt}_r(Q)\)</span> be the right multiplication group of <span class="SimpleMath">\(Q\)</span>, <span class="SimpleMath">\(S\)</span> a set of orbit representatives of <span class="SimpleMath">\(G\)</span> on <span class="SimpleMath">\(Q\)</span>, and <span class="SimpleMath">\(R=(R_x:x\in S)\)</span> (a collection of right transversals). Then <span class="SimpleMath">\((G,S,R)\)</span> is a rack/quandle envelope. Conversely, given a rack/quandle envelope <span class="SimpleMath">\((G,S,R)\)</span> on a set <span class="SimpleMath">\(Q\)</span> with <span class="SimpleMath">\(R=(r_x:x\in S)\)</span>, we can define right translations <span class="SimpleMath">\(R_y = r_x^{g_y} = g_y^{-1}r_xg_y\)</span>, where <span class="SimpleMath">\(g_y\)</span> is any element of <span class="SimpleMath">\(G\)</span> such that <span class="SimpleMath">\(g_y(x)=y\)</span>. Then <span class="SimpleMath">\((Q,\cdot)\)</span> with multiplication <span class="SimpleMath">\(x\cdot y = R_y(x)\)</span> is a rack/quandle.</p>

<p>In <strong class="pkg">RightQuasigroups</strong>, a rack/quandle envelope is represented as a list <code class="code">[G,S,R]</code>, where <code class="code">G</code> is a permutation group, <code class="code">S</code> is a list of points (orbit representatives) and <code class="code">R</code> is a list of elements of <code class="code">G</code>, one for each <code class="code">x</code> in <code class="code">S</code>. Functions that use rack/quandle envelopes accept either a single argument <code class="code">[G,S,R]</code> or three arguments <code class="code">G</code>, <code class="code">S</code>, <code class="code">R</code>.</p>

<p><a id="X841A4D657F2D0AE2" name="X841A4D657F2D0AE2"></a></p>

<h5>11.4-1 <span class="Heading">IsRackEnvelope and IsQuandleEnvelope</span></h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsRackEnvelope</code>( <var class="Arg">G</var>, <var class="Arg">reps</var>, <var class="Arg">perms</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsQuandleEnvelope</code>( <var class="Arg">G</var>, <var class="Arg">reps</var>, <var class="Arg">perms</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: <code class="code">true</code> if <var class="Arg">G</var>, <var class="Arg">reps</var>, <var class="Arg">perms</var> is a rack envelope (resp. quandle envelope). For the method to apply, <var class="Arg">G</var> must be a group and <var class="Arg">reps</var>, <var class="Arg">perms</var> must be lists. To return <code class="code">true</code>, <var class="Arg">G</var> must be a permutation group with orbit representatives <var class="Arg">reps</var> and <var class="Arg">perms</var><code class="code">[i]</code> must be an element of <span class="SimpleMath">\(C_G(G_x)\)</span> (resp. <span class="SimpleMath">\(Z(G_x)\)</span>), where <code class="code">x=reps[i]</code>, and the union of the conjugacy classes of the permutations in <var class="Arg">perms</var> must generate <var class="Arg">G</var>. A version with a single argument <code class="code">[</code><var class="Arg">G</var><code class="code">,</code><var class="Arg">reps</var><code class="code">,</code><var class="Arg">perms</var><code class="code">]</code> is also supported.</p>

<p><a id="X7D200C2D83FE158D" name="X7D200C2D83FE158D"></a></p>

<h5>11.4-2 <span class="Heading">RackEnvelope and QuandleEnvelope</span></h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; RackEnvelope</code>( <var class="Arg">Q</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; QuandleEnvelope</code>( <var class="Arg">Q</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: the rack envelope (quandle envelope) of the rack (quandle) as a list <code class="code">[G,reps,perms]</code>.</p>

<p><a id="X81F0417D7EA5504B" name="X81F0417D7EA5504B"></a></p>

<h5>11.4-3 RackByRackEnvelope</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; RackByRackEnvelope</code>( <var class="Arg">G</var>, <var class="Arg">reps</var>, <var class="Arg">perms</var>[, <var class="Arg">constructorStyle</var>] )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; QuandleByQuandleEnvelope</code>( <var class="Arg">G</var>, <var class="Arg">reps</var>, <var class="Arg">perms</var>[, <var class="Arg">constructorStyle</var>] )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: the rack (quandle) corresponding to the rack envelope (quandle envelope) <code class="code">[</code><var class="Arg">G</var><code class="code">,</code><var class="Arg">reps</var><code class="code">,</code><var class="Arg">perms</var><code class="code">]</code>. The underlying set will be the union of the orbits of <var class="Arg">G</var> on the representatives <var class="Arg">reps</var>. The resulting rack (quandle) is connected if <var class="Arg">G</var> has a single orbit. A version with a single non-optional argument <code class="code">[</code><var class="Arg">G</var><code class="code">,</code><var class="Arg">reps</var><code class="code">,</code><var class="Arg">perms</var><code class="code">]</code> is also supported.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Q := SmallQuandle( 10, 1000 );</span>
SmallQuandle( 10, 1000 )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">env := QuandleEnvelope( Q );</span>
[ Group([ (1,3,2)(7,8) ]), [ 1, 4, 5, 6, 7, 9, 10 ], 
  [ (), (), (1,2,3), (1,3,2)(7,8), (1,2,3), (1,3,2)(7,8), 
      (1,3,2)(7,8) ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Q2 := QuandleByQuandleEnvelope( env );</span>
&lt;quandle of size 10&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsomorphismQuandles( Q, Q2 );</span>
MappingByFunction( SmallQuandle( 10, 1000 ), &lt;quandle of size 10&gt;, fun\
ction( x ) ... end )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AsParentTransformation( last );</span>
IdentityTransformation
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">QuandleByQuandleEnvelope( env[1], env[2], env[3] ); # separate arguments also supported for envelopes</span>
&lt;quandle of size 10&gt;
</pre></div>

<p><a id="X8440413D8146C267" name="X8440413D8146C267"></a></p>

<h4>11.5 <span class="Heading">Subracks and subquandles</span></h4>

<p><a id="X7EACDAF081352D14" name="X7EACDAF081352D14"></a></p>

<h5>11.5-1 <span class="Heading">Testing subracks and subquandles</span></h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsSubrack</code>( <var class="Arg">Q</var>, <var class="Arg">S</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsSubquandle</code>( <var class="Arg">Q</var>, <var class="Arg">S</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: <code class="code">true</code> if <var class="Arg">S</var> is a subrack (subquandle) of the rack (quandle) <var class="Arg">Q</var>, else returns <code class="code">false</code>.</p>

<p><a id="X7E879779877E2A39" name="X7E879779877E2A39"></a></p>

<h5>11.5-2 <span class="Heading">Creating subracks and subquandles</span></h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Subrack</code>( <var class="Arg">Q</var>, <var class="Arg">gens</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Subquandle</code>( <var class="Arg">Q</var>, <var class="Arg">gens</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: the subrack (subquandle) of a rack (quandle) <var class="Arg">Q</var> generated by the list of elements <var class="Arg">gens</var>. We allow <var class="Arg">gens</var> to consist of elements of <var class="Arg">Q</var> or of elements of the underlying set of <var class="Arg">Q</var>. The resulting subalgebra will be index based (cf. Section <a href="chap1_mj.html#X81DECB427F4826CD"><span class="RefLink">1.8</span></a>) iff <var class="Arg">Q</var> is index based.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Q := AffineRack( 12, 5, 2, 6 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S := Subrack( Q, [ Q[2] ] );</span>
&lt;rack of size 2&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsSubrack( Q, S );</span>
true
</pre></div>

<p><a id="X7A34F665876B0F53" name="X7A34F665876B0F53"></a></p>

<h5>11.5-3 <span class="Heading">All subracks and subquandles</span></h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; AllSubracks</code>( <var class="Arg">Q</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; AllSubquandles</code>( <var class="Arg">Q</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: a list of all subracks (subquandles) of a rack (quandle) <var class="Arg">Q</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Q := ConjugationQuandle( SymmetricGroup( 3 ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( AllSubquandles( Q ), Size );</span>
[ 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 3, 5, 2, 4, 6, 3 ]
</pre></div>

<p><a id="X80773F578384A0CF" name="X80773F578384A0CF"></a></p>

<h5>11.5-4 <span class="Heading">Racks and quandles by generators</span></h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Rack</code>( <var class="Arg">gens...</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Quandle</code>( <var class="Arg">gens...</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; RackByGenerators</code>( <var class="Arg">gens...</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; QuandleByGenerators</code>( <var class="Arg">gens...</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; RackWithGenerators</code>( <var class="Arg">gens...</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; QuandleWithGenerators</code>( <var class="Arg">gens...</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>These functions are analogous to those described in Section <a href="chap3_mj.html#X852E2582803ABADD"><span class="RefLink">3.5</span></a></p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Q := ConjugationQuandle( SymmetricGroup( 3 ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S := QuandleWithGenerators( [ Q[(1,2)], Q[(1,2,3)] ] );</span>
&lt;quandle of size 5&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">GeneratorsOfMagma( S );</span>
[ r(1,2), r(1,2,3) ]
</pre></div>

<p><a id="X7B2647047A89F64B" name="X7B2647047A89F64B"></a></p>

<h4>11.6 <span class="Heading">Isomorphisms and isotopisms of racks and quandles</span></h4>

<p><a id="X86082383814A82A5" name="X86082383814A82A5"></a></p>

<h5>11.6-1 <span class="Heading">IsomorphismRacks, IsomorphismQuandles</span></h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsomorphismRacks</code>( <var class="Arg">Q1</var>, <var class="Arg">Q2</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsomorphismQuandles</code>( <var class="Arg">Q1</var>, <var class="Arg">Q2</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: an isomorphism between the racks (quandles) <var class="Arg">Q1</var> and <var class="Arg">Q2</var>, if one exists, else returns <code class="code">fail</code>. If an isomorphism from <var class="Arg">Q1</var> to <var class="Arg">Q2</var> exists, it is returned as a permutation of <span class="SimpleMath">\([1..n]\)</span>, where <span class="SimpleMath">\(n\)</span> is the size of <var class="Arg">Q1</var> (and hence also the size of <var class="Arg">Q2</var>).</p>

<p><a id="X7C45E9B67C1BB14D" name="X7C45E9B67C1BB14D"></a></p>

<h5>11.6-2 <span class="Heading">Racks and quandles up to isomorphism</span></h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; RacksUpToIsomorphism</code>( <var class="Arg">ls</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; QuandlesUpToIsomorphism</code>( <var class="Arg">ls</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: a sublist of <code class="code">ls</code> consisting of all racks (quandles) in <code class="code">ls</code> up to isomorphism.</p>

<p><a id="X7F53D3F18465885F" name="X7F53D3F18465885F"></a></p>

<h4>11.7 <span class="Heading">Groups associated with racks and quandles</span></h4>

<p><a id="X79A9BF8A84FC4590" name="X79A9BF8A84FC4590"></a></p>

<h5>11.7-1 AdjointGroup</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; AdjointGroup</code>( <var class="Arg">Q</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: the adjoint group associated with the rack <var class="Arg">Q</var>, that is, the free group on <var class="Arg">Q</var> with relations <span class="SimpleMath">\(b^{-1}ab = a*b\)</span>, where <span class="SimpleMath">\(a*b\)</span> is the product in the rack <var class="Arg">Q</var>. The generators inherit names from the elements of <var class="Arg">Q</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g := AdjointGroup( DihedralQuandle( 3 ) );</span>
&lt;fp group on the generators [ q0, q1 ]&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">GeneratorsOfGroup( g );</span>
[ q0, q1 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RelatorsOfFpGroup( g );</span>
[ q0^-1*q1^2*q0^-1, (q1^-1*q0)^3 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Size( g );</span>
infinity
</pre></div>


<div class="chlinkprevnextbot">&nbsp;<a href="chap0_mj.html">[Top of Book]</a>&nbsp;  <a href="chap0_mj.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap10_mj.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chap12_mj.html">[Next Chapter]</a>&nbsp;  </div>


<div class="chlinkbot"><span class="chlink1">Goto Chapter: </span><a href="chap0_mj.html">Top</a>  <a href="chap1_mj.html">1</a>  <a href="chap2_mj.html">2</a>  <a href="chap3_mj.html">3</a>  <a href="chap4_mj.html">4</a>  <a href="chap5_mj.html">5</a>  <a href="chap6_mj.html">6</a>  <a href="chap7_mj.html">7</a>  <a href="chap8_mj.html">8</a>  <a href="chap9_mj.html">9</a>  <a href="chap10_mj.html">10</a>  <a href="chap11_mj.html">11</a>  <a href="chap12_mj.html">12</a>  <a href="chapBib_mj.html">Bib</a>  <a href="chapInd_mj.html">Ind</a>  </div>

<hr />
<p class="foot">generated by <a href="https://www.math.rwth-aachen.de/~Frank.Luebeck/GAPDoc">GAPDoc2HTML</a></p>
</body>
</html>
