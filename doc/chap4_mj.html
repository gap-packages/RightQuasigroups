<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
         "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<script type="text/javascript"
  src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<title>GAP (RightQuasigroups) - Chapter 4: Mappings, transformations and permutations of right quasigroups</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8" />
<meta name="generator" content="GAPDoc2HTML" />
<link rel="stylesheet" type="text/css" href="manual.css" />
<script src="manual.js" type="text/javascript"></script>
<script type="text/javascript">overwriteStyle();</script>
</head>
<body class="chap4"  onload="jscontent()">


<div class="chlinktop"><span class="chlink1">Goto Chapter: </span><a href="chap0_mj.html">Top</a>  <a href="chap1_mj.html">1</a>  <a href="chap2_mj.html">2</a>  <a href="chap3_mj.html">3</a>  <a href="chap4_mj.html">4</a>  <a href="chap5_mj.html">5</a>  <a href="chap6_mj.html">6</a>  <a href="chap7_mj.html">7</a>  <a href="chap8_mj.html">8</a>  <a href="chap9_mj.html">9</a>  <a href="chap10_mj.html">10</a>  <a href="chap11_mj.html">11</a>  <a href="chap12_mj.html">12</a>  <a href="chapBib_mj.html">Bib</a>  <a href="chapInd_mj.html">Ind</a>  </div>

<div class="chlinkprevnexttop">&nbsp;<a href="chap0_mj.html">[Top of Book]</a>&nbsp;  <a href="chap0_mj.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap3_mj.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chap5_mj.html">[Next Chapter]</a>&nbsp;  </div>

<p id="mathjaxlink" class="pcenter"><a href="chap4.html">[MathJax off]</a></p>
<p><a id="X81106768871C276F" name="X81106768871C276F"></a></p>
<div class="ChapSects"><a href="chap4_mj.html#X81106768871C276F">4 <span class="Heading">Mappings, transformations and permutations of right quasigroups</span></a>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap4_mj.html#X8372074486AAC9EB">4.1 <span class="Heading">Mappings, transformations and permutations</span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap4_mj.html#X809F0CB8795CE362">4.2 <span class="Heading">Right quasigroup mapppings</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4_mj.html#X827D8C307D6A37B1">4.2-1 <span class="Heading">IsRightQuasigroupMapping, IsQuasigroupMapping, IsLoopMapping</span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4_mj.html#X82F342E6783402F3">4.2-2 AsRightQuasigroupMapping</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap4_mj.html#X8625B3897FEB526E">4.3 <span class="Heading">Canonical permutations and parent permutations</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4_mj.html#X7AC5F57584132B96">4.3-1 IsCanonicalPerm</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4_mj.html#X7B43498D7DB897BD">4.3-2 IsParentPerm</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4_mj.html#X7911AFFB87362C39">4.3-3 AsCanonicalPerm</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4_mj.html#X83BDDFAC79162437">4.3-4 AsParentPerm</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap4_mj.html#X81A111407DE04F9E">4.4 <span class="Heading">Canonical transformations and parent transformations</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4_mj.html#X78CBAF5C7F7C1193">4.4-1 IsCanonicalTransformation</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4_mj.html#X81D554C48215850F">4.4-2 IsParentTransformation</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4_mj.html#X7F68205186BD8B70">4.4-3 AsCanonicalTransformation</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4_mj.html#X7CA334737C472C70">4.4-4 AsParentTransformation</a></span>
</div></div>
</div>

<h3>4 <span class="Heading">Mappings, transformations and permutations of right quasigroups</span></h3>

<p><a id="X8372074486AAC9EB" name="X8372074486AAC9EB"></a></p>

<h4>4.1 <span class="Heading">Mappings, transformations and permutations</span></h4>

<p>Given right quasigroups <code class="code">Q1</code> and <code class="code">Q2</code>, a mapping from <code class="code">Q1</code> to <code class="code">Q2</code> is represented in one of the following ways:</p>


<ul>
<li><p>as a <strong class="pkg">GAP</strong> mapping with source <code class="code">Q1</code> and range <code class="code">Q2</code> (used for mappings between two distinct right quasigroups, for instance for homomorphisms),</p>

</li>
<li><p>as a transformation (a numerical analog of <strong class="pkg">GAP</strong> mappings, for instance for left translations of right quasigroups),</p>

</li>
<li><p>as a permutation (used for bijective mappings when <code class="code">Q1 = Q2</code>, for instance for translations in quasigroups, automorphisms, etc.).</p>

</li>
</ul>
<p>Moreveor, for a fixed right quasigroup <code class="code">Q</code>, permutations can be understood in two ways:</p>


<ul>
<li><p><em>Parent permutations</em>, whose indexing is based on the parent indices of elements of <code class="code">Q</code>. More precisely, a permutation <code class="code">f</code> is a parent permutation of <code class="code">Q</code> if it restricts to a permutation of the set <code class="code">ParentInd( Q )</code>. (Note that it is not required for <code class="code">f</code> to fix all points outside of <code class="code">ParentInd( Q )</code>.)</p>

</li>
<li><p><em>Canonical permutations</em>, whose indexing is based on the position of elements among elements of <code class="code">Q</code>. More precisely, a permutation <code class="code">f</code> is a canonical permutation on <code class="code">Q</code> if it restricts to a permutation on <code class="code">[1..Size(Q)]</code>. (Note that it is not required for <code class="code">f</code> to fix all points outside of <code class="code">[1..Size(Q)]</code>, not even to fix all points outside of <code class="code">[1..Size(Parent(Q))]</code>.)</p>

</li>
</ul>
<p>A permutation does not keep track of <code class="code">Q</code>, of course. The right quasigroup <code class="code">Q</code> must therefore be provided in order to construct a <strong class="pkg">GAP</strong> mapping from a permutation.</p>

<p>Similarly, for fixed right quasigroups <code class="code">Q1</code>, <code class="code">Q2</code>, transformations can be understood in two ways:</p>


<ul>
<li><p><em>Parent transformations</em>, whose indexing is based on the parent indices of elements of <code class="code">Q1</code> and <code class="code">Q2</code>. More precisely, a transformation <code class="code">t</code> is a parent transformation from <code class="code">Q1</code> to <code class="code">Q2</code> if for every <code class="code">i</code> in <code class="code">ParentInt( Q1 )</code> we have <code class="code">i^t</code> in <code class="code">ParentInd( Q2 )</code>.</p>

</li>
<li><p><em>Canonical transformations</em>, whose indexing is based on the position of elements among elements of <code class="code">Q1</code> and <code class="code">Q2</code>. More precisely, a transformation <code class="code">t</code> is a canonical transformation from <code class="code">Q1</code> to <code class="code">Q2</code> if for every <code class="code">i</code> in <code class="code">[1..Size(Q1)]</code> we have <code class="code">i^t</code> in <code class="code">[1..Size(Q2)]</code>.</p>

</li>
</ul>
<p>A transformation does not keep track of <code class="code">Q1</code> and <code class="code">Q2</code>. The right quasigroups <code class="code">Q1</code> and <code class="code">Q2</code> must therefore be provided in order to construct a <strong class="pkg">GAP</strong> mapping from a transformation.</p>

<p>Whenever possible, <strong class="pkg">RightQuasigroups</strong> works with parent permutations as default mappings, such as for right translations of quasigroups, right inner mappings of quasigroups, automorphisms, etc. The default permutation action in <strong class="pkg">RightQuasigroups</strong> treats permutations as parent permutations, that is, if <code class="code">Q</code> is a right quasigroup and <code class="code">f</code> is a permutation then <code class="code">(Q.i)^f</code> returns <code class="code">Q.(i^f)</code>.</p>

<p>When the mapping is not bijective or the source and target are not the same, the default option is a parent transformation.</p>

<p>Canonical permutations and canonical transformations are quite useful, too, for instance while working with multiplication tables.</p>

<p>The following example shows all possible conversions between the 5 types of bijective mappings in the situation when the source and target are the same. All details concerning the conversion functions and their arguments as well as additional examples will be given later. Note that the standard <strong class="pkg">GAP</strong> method <code class="code">AsPermutation</code> can be used to convert a transformation (that happens to permute its image) into a permutation, while the standard <strong class="pkg">GAP</strong> method <code class="code">AsTransformation</code> can be used to convert any permutation into a transformation.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Q := MoufangLoop( 12, 1 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S := Subloop( Q, [Q.3] );</span>
&lt;Moufang loop of size 3&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ParentInd( S ); # indices of S in Q</span>
[ 1, 3, 5 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">f := LeftTranslation( S, S.3 ); # automatically returned as a parent permutation</span>
(1,3,5)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">#</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"># CONVERTING PARENT PERMUTATIONS</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">#</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AsCanonicalPerm( S, f );</span>
(1,2,3)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AsTransformation( f ); # standard GAP function</span>
Transformation( [ 3, 2, 5, 4, 1 ] )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AsCanonicalTransformation( S, f );</span>
Transformation( [ 2, 3, 1 ] )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AsRightQuasigroupMapping( S, f ); # parent permutation expected by default</span>
MappingByFunction( &lt;Moufang loop of size 3&gt;, &lt;Moufang loop of size 3&gt;,\
 function( x ) ... end )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">#</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"># CONVERTING CANONICAL PERMUTATIONS</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">#</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g := (1,2,3);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AsParentPerm( S, g );</span>
(1,3,5)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AsTransformation( g ); # standard GAP function</span>
Transformation( [ 2, 3, 1 ] )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AsParentTransformation( S, g );</span>
Transformation( [ 3, 2, 5, 4, 1 ] )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AsRightQuasigroupMapping( S, g, true ); # optional bool needed for canonical</span>
MappingByFunction( &lt;Moufang loop of size 3&gt;, &lt;Moufang loop of size 3&gt;,\
 function( x ) ... end )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">#</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"># CONVERTING PARENT TRANSFORMATIONS</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">#</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">h := Transformation( [3,2,5,4,1] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AsPermutation( h ); # standard GAP function</span>
(1,3,5)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AsCanonicalPerm( S, h );</span>
(1,2,3)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AsCanonicalTransformation( S, S, h );</span>
Transformation( [ 2, 3, 1 ] )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AsRightQuasigroupMapping( S, S, h ); # parent transformation expected by default</span>
MappingByFunction( &lt;Moufang loop of size 3&gt;, &lt;Moufang loop of size 3&gt;,\
 function( x ) ... end )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">#</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"># CONVERTING CANONICAL TRANSFORMATIONS</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">#</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">k := Transformation( [ 2, 3, 1 ] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AsPermutation( k ); # default GAP function</span>
(1,2,3)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AsParentPerm( S, k );</span>
(1,3,5)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AsParentTransformation( S, S, k );</span>
Transformation( [ 3, 2, 5, 4, 1 ] )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AsRightQuasigroupMapping( S, S, k, true ); # optional bool needed for canonical</span>
MappingByFunction( &lt;Moufang loop of size 3&gt;, &lt;Moufang loop of size 3&gt;,\
 function( x ) ... end )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">#</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"># CONVERTING RIGHT QUASIGROUP MAPPINGS</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">#</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">m := last;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AsParentPerm( m );</span>
(1,3,5)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AsCanonicalPerm( m );</span>
(1,2,3)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AsParentTransformation( m );</span>
Transformation( [ 3, 2, 5, 4, 1 ] )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AsCanonicalTransformation( m );</span>
Transformation( [ 2, 3, 1 ] )
</pre></div>

<p><a id="X809F0CB8795CE362" name="X809F0CB8795CE362"></a></p>

<h4>4.2 <span class="Heading">Right quasigroup mapppings</span></h4>

<p>Mappings between right quasigroups are <strong class="pkg">GAP</strong> mappings - the standard methods for mappings therefore apply. The following example creates the squaring mapping on a loop <code class="code">Q</code> and calculates the image of an element of <code class="code">Q</code>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Q := MoufangLoop( 12, 1 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">m := MappingByFunction( Q, Q, x -&gt; x*x );</span>
MappingByFunction( MoufangLoop( 12, 1 ), MoufangLoop( 12, 1 ), functio\
n( x ) ... end )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">[ Source( m ) = Q, Range( m ) = Q ];</span>
[ true, true ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Q.2*Q.2 = Q.2^m;</span>
true
</pre></div>

<p><a id="X827D8C307D6A37B1" name="X827D8C307D6A37B1"></a></p>

<h5>4.2-1 <span class="Heading">IsRightQuasigroupMapping, IsQuasigroupMapping, IsLoopMapping</span></h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsRightQuasigroupMapping</code>( <var class="Arg">m</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsQuasigroupMapping</code>( <var class="Arg">m</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsLoopMapping</code>( <var class="Arg">m</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: <code class="code">true</code> if <var class="Arg">m</var> is a right quasigroup (quasigroup, loop) mapping, that is, a <strong class="pkg">GAP</strong> mapping in which both the source and the range are right quasigroups (quasigroups, loops).</p>

<p><a id="X82F342E6783402F3" name="X82F342E6783402F3"></a></p>

<h5>4.2-2 AsRightQuasigroupMapping</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; AsRightQuasigroupMapping</code>( <var class="Arg">Q1</var>, <var class="Arg">Q2</var>, <var class="Arg">f</var>[, <var class="Arg">isCanonical</var>] )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: In this form, returns a right quasigroup mapping with source <var class="Arg">Q1</var> and range <var class="Arg">Q2</var> determined by the transformation <var class="Arg">f</var>. If the optional argument is not given, it is checked that <var class="Arg">f</var> is a parent transformation from <code class="code">Q1</code> to <code class="code">Q2</code>, and then the returned mapping <code class="code">m</code> satisfies <code class="code">(Q1.i)^m = Q2.j</code> iff <code class="code">i^f=j</code>. If the optional argument is set to <code class="code">true</code>, is it checked that <var class="Arg">f</var> is a canonical transformation, and then the returned mapping <code class="code">m</code> satisfies <code class="code">(Elements(Q1)[i])^m = Elements(Q2)[j]</code> iff <code class="code">i^f=j</code>.</p>

<p>In the form <code class="code">AsRightQuasigroupMapping( </code><var class="Arg">Q</var><code class="code">, </code><var class="Arg">f</var><code class="code">[, </code><var class="Arg">isCanonical</var><code class="code">] )</code>, returns a right quasigroup mapping with source and range equal to <var class="Arg">Q</var>, determined by the permutation <var class="Arg">f</var>.</p>

<p><a id="X8625B3897FEB526E" name="X8625B3897FEB526E"></a></p>

<h4>4.3 <span class="Heading">Canonical permutations and parent permutations</span></h4>

<p><a id="X7AC5F57584132B96" name="X7AC5F57584132B96"></a></p>

<h5>4.3-1 IsCanonicalPerm</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsCanonicalPerm</code>( <var class="Arg">Q</var>, <var class="Arg">f</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: <code class="code">true</code> if the permutation <var class="Arg">f</var> is a canonical permutation on the right quasigroup <var class="Arg">Q</var>, (that is, if <var class="Arg">f</var> restricts to a permutation of <code class="code">[1..Size(</code><var class="Arg">Q</var><code class="code">)]</code>), else returns <code class="code">false</code>.</p>

<p><a id="X7B43498D7DB897BD" name="X7B43498D7DB897BD"></a></p>

<h5>4.3-2 IsParentPerm</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsParentPerm</code>( <var class="Arg">Q</var>, <var class="Arg">f</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: <code class="code">true</code> if <var class="Arg">f</var> is a parent permutation on right quasigroup <code class="code">Q</code> (that is, if <var class="Arg">f</var> restricts to a permutation of the set <code class="code">ParentInd(</code><var class="Arg">Q</var><code class="code">)</code>), else returns <code class="code">false</code>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Q := MoufangLoop( 12, 1 );; S := Subloop( Q, [Q.3] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ParentInd( S );</span>
[ 1, 3, 5 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">(Q.3)^(3,4) = Q.4;</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsParentPerm( S, (3,4) ); # does not act on [ 1, 3, 5 ] </span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsParentPerm( S, (3,5) ); # acts on [ 1, 3, 5 ]</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsParentPerm( S, (3,5)(7,8) ); # behavior outside of S is ignored</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCanonicalPerm( S, (1,2,3) ); # acts on [1..Size(S)]</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCanonicalPerm( S, (1,3,5) ); # does not act on [1..Size(S)]</span>
false
</pre></div>

<p><a id="X7911AFFB87362C39" name="X7911AFFB87362C39"></a></p>

<h5>4.3-3 AsCanonicalPerm</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; AsCanonicalPerm</code>( <var class="Arg">arg</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: the canonical permutation determined by the argument(s) <var class="Arg">arg</var>. If the argument is a bijective right quasigroup mapping <code class="code">m</code> with source <code class="code">Q1</code> and range <code class="code">Q2</code>, returns a permutation <code class="code">f</code> such that <code class="code">i^f=j</code> iff <code class="code">Elements(Q1)[i]^m = Elements(Q2)[j]</code>. If the arguments are a right quasigroup <code class="code">Q</code> and its bijective parent transformation <code class="code">m</code>, returns a permutation <code class="code">f</code> such that <code class="code">i^f=j</code> iff <code class="code">ParentInd(Q)[i]^m = ParentInd(Q)[j]</code>. If the arguments are a right quasigroup <code class="code">Q</code> and its parent permutation <code class="code">m</code>, returns a permutation <code class="code">f</code> such that <code class="code">i^f=j</code> iff <code class="code">ParentInd(Q)[i]^m = ParentInd(Q)[j]</code>.</p>

<p><a id="X83BDDFAC79162437" name="X83BDDFAC79162437"></a></p>

<h5>4.3-4 AsParentPerm</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; AsParentPerm</code>( <var class="Arg">arg</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: the parent permutation determined by the argument(s) <var class="Arg">arg</var>. If the argument is a bijective right quasigroup mapping <code class="code">m</code> on <code class="code">Q</code>, returns a permutation <code class="code">f</code> such that <code class="code">i^f=j</code> iff <code class="code">(Q.i)^m = Q.j</code> (for <code class="code">i</code> in <code class="code">ParentInd(Q)</code>). If the arguments are a right quasigroup <code class="code">Q</code> and its bijective canonical transformation <code class="code">m</code>, returns a permutation <code class="code">f</code> such that <code class="code">ParentInd(Q)[i]^f=ParentInd(Q)[j]</code> iff <code class="code">i^m = j</code>. If the arguments are a right quasigroup <code class="code">Q</code> and its canonical permutation <code class="code">m</code>, returns a permutation <code class="code">f</code> such that <code class="code">ParentInd(Q)[i]^f=ParentInd(Q)[j]</code> iff <code class="code">i^m = j</code>.</p>

<p>See <code class="code">ParentInd</code>, too.</p>

<p><a id="X81A111407DE04F9E" name="X81A111407DE04F9E"></a></p>

<h4>4.4 <span class="Heading">Canonical transformations and parent transformations</span></h4>

<p><a id="X78CBAF5C7F7C1193" name="X78CBAF5C7F7C1193"></a></p>

<h5>4.4-1 IsCanonicalTransformation</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsCanonicalTransformation</code>( <var class="Arg">Q1</var>, <var class="Arg">Q2</var>, <var class="Arg">t</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: <code class="code">true</code> if <var class="Arg">t</var> is a canonical transformation from right quasigroup <var class="Arg">Q1</var> to right quasigroup <var class="Arg">Q2</var>, that is, if <code class="code">i^f</code> is in <code class="code">[1..Size(Q2)]</code> for all <code class="code">i</code> in <code class="code">[1..Size(Q1)]</code>.</p>

<p><a id="X81D554C48215850F" name="X81D554C48215850F"></a></p>

<h5>4.4-2 IsParentTransformation</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsParentTransformation</code>( <var class="Arg">Q1</var>, <var class="Arg">Q2</var>, <var class="Arg">t</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: <code class="code">true</code> if <var class="Arg">t</var> is a parent transformation from right quasigroup <var class="Arg">Q1</var> to right quasigroup <var class="Arg">Q2</var> (that is, if <code class="code">i^f</code> is in <code class="code">ParentInd( Q2 )</code> for all <code class="code">i</code> in <code class="code">ParentInd( Q1 )</code>), else returns <code class="code">false</code>.</p>

<p><a id="X7F68205186BD8B70" name="X7F68205186BD8B70"></a></p>

<h5>4.4-3 AsCanonicalTransformation</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; AsCanonicalTransformation</code>( <var class="Arg">arg</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: the canonical transformation determined by the argument(s) <var class="Arg">arg</var>. If the argument is a right quasigroup mapping <code class="code">m</code> with source <code class="code">Q1</code> and range <code class="code">Q2</code>, returns a transformation <code class="code">t</code> such that <code class="code">i^t=j</code> iff <code class="code">Elements(Q1)[i]^m = Elements(Q2)[j]</code>. If the arguments are two right quasigroups <code class="code">Q1</code>, <code class="code">Q2</code> and their parent transformation <code class="code">m</code>, returns a tranformation <code class="code">t</code> such that <code class="code">i^t=j</code> iff <code class="code">ParentInd(Q1)[i]^m = ParentInd(Q2)[j]</code>. If the arguments are a right quasigroup <code class="code">Q</code> and its parent permutation <code class="code">m</code>, returns a tranformation <code class="code">t</code> such that <code class="code">i^t=j</code> iff <code class="code">ParentInd(Q)[i]^m = ParentInd(Q)[j]</code>.</p>

<p><a id="X7CA334737C472C70" name="X7CA334737C472C70"></a></p>

<h5>4.4-4 AsParentTransformation</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; AsParentTransformation</code>( <var class="Arg">arg</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: the parent transformation determined by the argument(s) <var class="Arg">arg</var>. If the argument is a right quasigroup mapping <code class="code">m</code> with source <code class="code">Q1</code> and range <code class="code">Q2</code>, returns a transformation <code class="code">t</code> such that <code class="code">i^t=j</code> iff <code class="code">(Q1.i)^m = Q2.j</code> (for <code class="code">i</code> in <code class="code">ParentInd(Q1)</code>). If the arguments are two right quasigroups <code class="code">Q1</code>, <code class="code">Q2</code> and their canonical transformation <code class="code">m</code>, returns a tranformation <code class="code">t</code> such that <code class="code">ParentInd(Q1)[i]^t=ParentInd(Q2)[j]</code> iff <code class="code">i^m = j</code>. If the arguments are a right quasigroup <code class="code">Q</code> and its canonical permutation <code class="code">m</code>, returns a tranformation <code class="code">t</code> such that <code class="code">ParentInd(Q)[i]^t=ParentInd(Q)[j]</code> iff <code class="code">i^m = j</code>.</p>

<p>See <code class="code">ParentInd</code>, too.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Q := AsLoop( SymmetricGroup( 4 ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S1 := Subloop( Q, [ Q[(1,2,3)] ] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S2 := Subloop( Q, [ Q[(1,4)]*Q[(1,2,3)]*Q[(1,4)] ] );; # conjugate subloop</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">m := MappingByFunction( S1, S2, x-&gt; Q[(1,4)]*x*Q[(1,4)] ); # conjugation S1 -&gt; S2</span>
MappingByFunction( &lt;associative loop of size 3&gt;, &lt;associative loop of \
size 3&gt;, function( x ) ... end )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ParentInd( S1 );</span>
[ 1, 9, 13 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ParentInd( S2 );</span>
[ 1, 4, 5 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">t := AsParentTransformation( m ); </span>
Transformation( [ 1, 2, 3, 4, 5, 6, 7, 8, 4, 10, 11, 12, 5 ] )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsParentTransformation( S1, S2, t );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AsCanonicalTransformation( m );</span>
IdentityTransformation
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCanonicalTransformation( S1, S2, last );</span>
true
</pre></div>


<div class="chlinkprevnextbot">&nbsp;<a href="chap0_mj.html">[Top of Book]</a>&nbsp;  <a href="chap0_mj.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap3_mj.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chap5_mj.html">[Next Chapter]</a>&nbsp;  </div>


<div class="chlinkbot"><span class="chlink1">Goto Chapter: </span><a href="chap0_mj.html">Top</a>  <a href="chap1_mj.html">1</a>  <a href="chap2_mj.html">2</a>  <a href="chap3_mj.html">3</a>  <a href="chap4_mj.html">4</a>  <a href="chap5_mj.html">5</a>  <a href="chap6_mj.html">6</a>  <a href="chap7_mj.html">7</a>  <a href="chap8_mj.html">8</a>  <a href="chap9_mj.html">9</a>  <a href="chap10_mj.html">10</a>  <a href="chap11_mj.html">11</a>  <a href="chap12_mj.html">12</a>  <a href="chapBib_mj.html">Bib</a>  <a href="chapInd_mj.html">Ind</a>  </div>

<hr />
<p class="foot">generated by <a href="https://www.math.rwth-aachen.de/~Frank.Luebeck/GAPDoc">GAPDoc2HTML</a></p>
</body>
</html>
