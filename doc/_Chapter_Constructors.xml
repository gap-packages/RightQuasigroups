<?xml version="1.0" encoding="UTF-8"?>

<!-- This is an automatically generated file. -->
<Chapter Label="Chapter_Constructors">
<Heading>Constructors</Heading>

<Section Label="Section_OptionalArguments">
<Heading>Optional arguments in constructors</Heading>

 <P/>Almost all constructors (exceptions will be noted) allow two optional boolean arguments <Code>indexBased</Code> and <Code>checkArgs</Code>.
 <P/>The value of <Code>indexBased</Code> determines if the constructed right quasigroup will be index based, cf. Section
 <Ref Sect="Section_IndexBased"/>. If <Code>indexBased</Code> is not provided, index based right quasigroups are constructed
 by default.
 <P/>The value of <Code>checkArgs</Code> determines if the arguments of the constructor will be checked for
 mathematical correctness. If <Code>checkArgs</Code> is not provided, the arguments are not checked by default.
 Being a second optional argument of constructors, <Code>checkArgs</Code> can be given only if <Code>indexBased</Code> is also given.
 <P/>We provide the <Code>checkArgs</Code> mechanism rather than the standard naming mechanism of &GAP; in which <Code>FunctionNC</Code>
 does not check its arguments while the corresponding <Code>Function</Code> does check its arguments, because:
 (a) the <Code>NC</Code> mechanism would effectively double the number of constructors,
 (b) in their code, users can easily switch between checking and not checking of arguments
 by globally changing the value of their variable used for <Code>checkArgs</Code>.
</Section>


<Section Label="Section_Converting">
<Heading>Converting betwen right quasigroups, quasigroups and loops</Heading>

 <P/>While &GAP; does not automatically recognize a right quasigroup as a quasigroup or a loop (if it happens to 
 be one mathematically), it is possible to test these properties and convert the algebras up and down as desired.
<ManSection Label="AutoDoc_generated_group4">
<Heading>IsRightQuasigroupMagma, IsLeftQuasigroupMagma, IsQuasigroupMagma and IsLoopMagma</Heading>
  <Prop Arg="M" Name="IsRightQuasigroupMagma" Label="for IsMagma"/>
  <Prop Arg="M" Name="IsLeftQuasigroupMagma" Label="for IsMagma"/>
  <Prop Arg="M" Name="IsQuasigroupMagma" Label="for IsMagma"/>
  <Prop Arg="M" Name="IsLoopMagma" Label="for IsMagma"/>
 <Returns><Code>true</Code> if the magma <Arg>M</Arg> is a right quasigroup (resp. left quasigroup, quasigroup, loop)  mathematically, else returns <Code>false</Code>. 
</Returns>
 <Description>
<P/>
 </Description>
</ManSection>


 <P/>We also support <Code>IsLatinMagma</Code> as a synonym of <Code>IsQuasigroupMagma</Code> since the multiplication
 table of quasigroups are Latin squares.
 <P/>Note that an explicit check will be carried out by each of <Code>IsRightQuasigroupMagma</Code>,
 <Code>IsLeftQuasigroupMagma</Code>, <Code>IsQuasigroupMagma</Code> and <Code>IsLoopMagma</Code> even if the underlying magma
 is declared to be a right quasigroup, quasigroup, loop, group, etc.
 To check only if a magma <Code>M</Code> contains a neutral element, it is also possible to call the &GAP; function
 <Code>MultiplicativeNeutralElement( M )</Code>, which returns a neutral element of <Code>M</Code> if one exists
 and <Code>fail</Code> otherwise.
<ManSection Label="AutoDoc_generated_group5">
<Heading>AsRightQuasigroup, AsQuasigroup and AsLoop</Heading>
  <Func Arg="M[, indexBased, checkArgs]" Name="AsRightQuasigroup" />
  <Func Arg="M[, indexBased, checkArgs]" Name="AsQuasigroup" />
  <Func Arg="M[, indexBased, checkArgs]" Name="AsLoop" />
 <Description>
<P/>
 </Description>
</ManSection>


 <P/>Given a magma <Code>M</Code> that is mathematically a right quasigroup, a quasigroup or a loop,
 returns the corresponding right quasigroup, quasigroup or loop, respectively. 
 If <Code>M</Code> cannot be converted, returns <Code>fail</Code>.
 <P/>If <Code>M</Code> is a declared additive group, the additive operation is used as multiplication.
 If <Code>M</Code> is a declared group, the multiplicative operation is used as multiplication.
<Example><![CDATA[
gap> M := MagmaByMultiplicationTable( [ [1,1], [2,2] ] );;
gap> Elements( M );
[ m1, m2 ]
gap> IsRightQuasigroupMagma( M );
true
gap> R := AsRightQuasigroup( M );
<right quasigroup of size 2>
gap> Elements( R );
[ rm1, rm2 ]
gap> IsQuasigroupMagma( R ); # synonym of IsLatinMagma
false
gap> AsQuasigroup( M ); # arguments of constructors are by default not checked!
<quasigroup of size 2>
gap> AsQuasigroup( M, true, true ); # the second optional argument will force a check
fail
gap> G := Group((1,2,3));; IsLoopMagma( G );
true
gap> L := AsLoop( G ); # multiplicative group
<loop of size 3>
gap> Elements( L );
[ l(), l(1,2,3), l(1,3,2) ]
gap> AsRightQuasigroup(GF(7)^2); # additive group
<right quasigroup of size 49>
]]></Example>


</Section>


<Section Label="Chapter_Constructors_Section_A_two-step_constructor">
<Heading>*A two-step constructor</Heading>

 <P/>Most constructors of &RightQuasigroups; work in two steps. In the first step, a shell of an algebra is created,
 with the underlying set and elements stored but with no multiplication function assigned.
 In the second step, the multiplication function is added, depending
 on the data provided by the user in the constructor.
 <P/>The reason for this approach, which is particularly useful for non-index based right quasigroups,
 is that the multiplication function might depend on 
 data that needs to be stored in the right quasigroup and be accessible. The first
 step creates the desired &GAP; object so that the multiplication function added
 in the second step can point to the stored data.
<ManSection>
  <Func Arg="category, S[, indexBased]" Name="RQ_AlgebraShell" />
 <Returns>an algebra shell of the appropriate category on the underlying set <Code>S</Code>.  The value of <Code>category</Code> must be <Code>IsRightQuasigroup</Code>, <Code>IsQuasigroup</Code> or <Code>IsLoop</Code>.
</Returns>
 <Description>
<P/>
 </Description>
</ManSection>


<ManSection>
  <Func Arg="Q" Name="RQ_AddDefaultOperations" />
 <Returns><Code>true</Code>
</Returns>
 <Description>
This method adds all required unary and binary operations to the right quasigroup shell <Code>Q</Code>.
 The implied right division is always added. The implied left division is added if <Code>Q</Code> is a declared quasigroup.
 The ipmlied neutral element is added if <Code>Q</Code> is a declared loop.
 Let F = FamilyObj( Q.1 ). If <Code>Q</Code> is indexBased, it is assumed that F!.multTable is bound.
 If <Code>Q</Code> is not index based, it is assumed that F!.mult is bound.
 </Description>
</ManSection>


 <P/>The following simple examples illustrates the approach, first for non-index based algebras
<Example><![CDATA[
gap> Q := RQ_AlgebraShell( IsRightQuasigroup, GF(5), false );
<right quasigroup shell of size 5>
gap> F := FamilyObj( Q.1 );;
gap> F!.mult := function(x,y) return x+y; end;;
gap> Q; # still a shell since right division is not bound
<right quasigroup shell of size 5> 
gap> Q.1*Q.1; # multiplication already works since Q is not index based and F!.mult is bound
r0*Z(5)
gap> RQ_AddDefaultOperations( Q );
true
gap> Q; # all needed operations for the right quasigroup are now bound
<right quasigroup of size 5>
gap> Q.1/Q.1;
r0*Z(5)
]]></Example>


 <P/>and now for index based algebras:
<Example><![CDATA[
gap> Q := RQ_AlgebraShell( IsRightQuasigroup, GF(5) );
<right quasigroup shell of size 5>
gap> F := FamilyObj( Q.1 );
gap> F!.multTable := List( GF(5), x-> List( GF(5), y -> Position( Elements(GF(5)), x+y ) ) );;
gap> Q; # still a shell since right division is not bound
<right quasigroup shell of size 5> 
gap> Q.1*Q.1; # multiplication already works since Q is index based and F!.multTable is bound
r0*Z(5)
gap> RQ_AddDefaultOperations( Q );
true
gap> Q; # all needed operations for the right quasigroup are now bound
<right quasigroup of size 5>
gap> Q.1/Q.1;
r0*Z(5)
]]></Example>


</Section>


<Section Label="Section_Cayley">
<Heading>Constructors by Cayley table</Heading>

<Subsection Label="Chapter_Constructors_Section_Constructors_by_Cayley_table_Subsection_Cayley_tables_versus_multiplication_tables">
<Heading>Cayley tables versus multiplication tables</Heading>

 <P/>Given a right quasigroup <Code>Q</Code> of size <Math>n</Math> with underlying set <Math>S</Math>, the <Index>Cayley table</Index>
 <Emph>Cayley table</Emph> of <Code>Q</Code> is the <Math>n\times n</Math> array with rows and columns
 implictly labeled by the elements of (the sorted list) <Math>S</Math>
 such that the cell in row <Math>x</Math> and column <Math>y</Math> contains the element <Math>xy\in S</Math>.
 <P/>In accordance with &GAP; conventions, given a magma <Code>M</Code> of size <Math>n</Math> with <Math>m_i</Math> denoting the <Math>i</Math>ith element of <Code>M</Code>,
 the <Index>multiplication table</Index><Emph>multiplication table</Emph> of <Code>Q</Code>
 is the <Math>n\times n</Math> array with rows and columns implicitly labeled by <Math>[1..n]</Math> such that
 the cell in row <Math>i</Math> and column <Math>j</Math> contains <Math>k</Math> iff <Math>m_im_j=m_k</Math>.
 <P/>It is also possible to form an <Math>n\times n</Math> array with rows and columns implicitly labeled by &GAP; elements
 of <Code>Q</Code> so that the cell in row <Code>x</Code> and column <Code>y</Code> contains the &GAP; element <Code>x*y</Code>. Such a table can be quickly
 constructed from the Cayley table <Code>ct</Code> of <Code>Q</Code> by <Code>List( ct, row -> List( row, x -> Q[x] ) )</Code>, for instance.
 We do not introduce terminology for such tables, nor do we provide any methods for dealing with them.
 <P/>Analogous conventions apply to right division and left division.
</Subsection>


<ManSection Label="AutoDoc_generated_group6">
<Heading>Cayley tables and multiplication tables of right quasigroups</Heading>
  <Attr Arg="Q" Name="MultiplicationTable" Label="for IsRightQuasigroup"/>
  <Attr Arg="Q" Name="CayleyTable" Label="for IsRightQuasigroup"/>
  <Attr Arg="Q" Name="RightDivisionTable" Label="for IsRightQuasigroup"/>
  <Attr Arg="Q" Name="RightDivisionCayleyTable" Label="for IsRightQuasigroup"/>
  <Attr Arg="Q" Name="LeftDivisionTable" Label="for IsQuasigroup"/>
  <Attr Arg="Q" Name="LeftDivisionCayleyTable" Label="for IsQuasigroup"/>
 <Returns>the multiplication table, Cayley table, right division table,  right division Cayley table, left division table and left division Cayley table of right quasigroup <Code>Q</Code>,
  respectively. For the left divisions, <Code>Q</Code> must be a declared quasigroup.
</Returns>
 <Description>
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group7">
<Heading>Constructing division tables from multiplication tables</Heading>
  <Oper Arg="Q" Name="RightDivisionTableFromMultiplicationTable" Label="for IsRectangularTable"/>
  <Oper Arg="Q" Name="LeftDivisionTableFromMultiplicationTable" Label="for IsRectangularTable"/>
 <Description>
<P/>
 </Description>
</ManSection>


 <P/>It is possible to construct a right division table from the multiplication table
 of a right quasigroup <Code>Q</Code> of size <Math>n</Math> in <Math>O(n^2)</Math>, rather than naively in <Math>O(n^3)</Math>.
 The quick algorithm is used in the above two methods which 
 return the right division table and the left division table of a right quasigroup <Code>Q</Code>, respectively.
 For the left division, <Code>Q</Code> must be a declared quasigroup.
<ManSection Label="AutoDoc_generated_group8">
<Heading>Testing Cayley tables</Heading>
  <Oper Arg="ct" Name="IsRightQuasigroupCayleyTable" Label="for IsRectangularTable"/>
  <Oper Arg="ct" Name="IsQuasigroupCayleyTable" Label="for IsRectangularTable"/>
  <Oper Arg="ct" Name="IsLoopCayleyTable" Label="for IsRectangularTable"/>
 <Returns><Code>true</Code> if <Code>ct</Code> is a Cayley table of a right quasigroup, quasigroup or loop, respectively,  otherwise returns <Code>false</Code>.
  The underlying set it understood to be the ordered set of elements contained in the first column of <Code>ct</Code>.
  This is a logical choice for right quasigroups.
</Returns>
 <Description>
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group9">
<Heading>Creating right quasigroups by Cayley table</Heading>
  <Func Arg="ct[, indexBased, checkArgs]" Name="RightQuasigroupByCayleyTable" />
  <Func Arg="ct[, indexBased, checkArgs]" Name="QuasigroupByCayleyTable" />
  <Func Arg="ct[, indexBased, checkArgs]" Name="LoopByCayleyTable" />
 <Description>
<P/>
 </Description>
</ManSection>


 <P/>Returns the right quasigroup, quasigroup or loop with Cayley table <Code>ct</Code>, respectively.
 See Section <Ref Sect="Section_OptionalArguments"/> for the optional arguments.
<Example><![CDATA[
gap> ct := [ [ "red", "white", "white" ], [ "blue", "blue", "red" ], [ "white", "red", "blue" ] ];;
gap> IsRightQuasigroupCayleyTable( ct );
true
gap> Q := RightQuasigroupByCayleyTable( ct );
<right quasigroup of size 3>
gap> Display( MultiplicationTable( Q ) ); # note the ordering of elements, with rows and columns implicitly labeled 1, 2, 3
[ [  2,  3,  3 ],
  [  1,  1,  2 ],
  [  3,  2,  1 ] ]
gap> Display( CayleyTable( Q ) );
[ [ "red", "white", "white" ],
  [ "blue", "blue", "red" ],
  [ "white", "red", "blue" ] ]
gap> Elements( Q );
[ rblue, rred, rwhite ]
gap> IsQuasigroupCayleyTable( ct );
false
gap> ct2 := [ [0,1],[1,0] ];;
gap> IsQuasigroupCayleyTable(ct2); IsLoopCayleyTable(ct2);
true
true
gap> QuasigroupByCayleyTable(ct2);
<quasigroup of size 2>
gap> LoopByCayleyTable(ct2);
<loop of size 2>
gap> One(last);
l0
]]></Example>


</Section>


<Section Label="Section_Function">
<Heading>Constructors by function</Heading>

 <P/>In this section we describe how to construct right quasigroups, quasigroups and loops by functions.
 <P/>To fix terminology, we say that a function <Math>f:S\times S\to S</Math> is a <Index>right quasigroup function</Index>
 <Emph>right quasigroup function</Emph> if for every <Math>x\in S</Math> the function <Math>R_x:S\to S</Math> defined by
 <Math>R_x(y) = f(y,x)</Math> is a permutation of <Math>S</Math>. A right quasigroup function <Math>f:S\times S\to S</Math> is
 a <Index>quasigroup function</Index><Emph>quasigroup function</Emph> if for every <Math>x\in S</Math> the function
 <Math>L_x:S\to S</Math> defined by <Math>L_x(y) = f(x,y)</Math> is a permutation of <Math>S</Math>. Finally, a quasigroup function
 <Math>f:S\times S\to S</Math> is a <Index>loop function</Index><Emph>loop function</Emph> if there is <Math>e\in S</Math> such that
 <Math>f(e,x)=x=f(x,e)</Math> for every <Math>x\in S</Math>.
<Subsection Label="Subsection_ConstructorArguments">
<Heading>Arguments used in constructors by function</Heading>

 <P/>When constructing right quasigroups, quasigroups and loops by function(s), &RightQuasigroups; assumes
 that the arguments are given as follows:
 <List>
 <Item>The first argument is the underlying set of the algebra.</Item>
 <Item>The second argument is the multiplication function.</Item>
 <Item>Optional arguments that lie in the filter <Code>IsFunction</Code> correspond to right division
 and left division, in this order. (In particular, it is not possible to specify left division
 without first specifying right division.)</Item>
 <Item>Optional arguments that lie in the filter <Code>IsBool</Code> correspond to <Code>indexBased</Code>
 and <Code>checkArgs</Code>, in this order. (See Section <Ref Sect="Section_OptionalArguments"/>.)</Item>
 <Item>The first optional argument that lies neither in <Code>IsFunction</Code> nor in <Code>IsBool</Code> corresponds
 to the neutral element. (So it is unfortunately not possible to specify in this way a neutral element that lies in
 <Code>IsFunction</Code> or in <Code>IsBool</Code>.)</Item>
 </List>
 <P/>If the optional right division function is not given, it will be automatically inferred from
 the multiplication function. In case of quasigroups an loops,
 if the optional left division function is not given, it will be automatically inferred from
 the multiplication function.
 Likewise, in case of loops, if the optional neutral element is not given, it will be automatically inferred
 from the multiplication function.
 <P/>Note that providing the division functions as arguments of non-index based algebras
 will typically make the division operations faster than by relying on the inferred divisions.
 For instance, if <Math>f(x,y)=x+y</Math> is the multiplication function and the user 
 also provides the right division function <Math>g(x,y) = x-y</Math>, the right division will be performed faster
 than the default right division that searches for the first element <Math>z</Math> such that <Math>x=f(z,y)</Math>.
 <P/>Similar conventions hold for the methods that check whether given function(s) constitute 
 right quasigroup, quasigroup or loop function(s), except that the <Code>indexBased</Code> and <Code>checkArgs</Code> arguments
 are void and missing operations are not automatically inferred from the multiplication.
</Subsection>


<ManSection>
  <Func Arg="S, mult[, rdiv]" Name="IsRightQuasigroupFunction" />
 <Returns><Code>true</Code> if <Code>mult</Code> is a right quasigroup function on <Code>S</Code>, else returns <Code>false</Code>.  (See Subsection <Ref Subsect="Subsection_ConstructorArguments"/> for how the optional arguments are treated.)
  If <Code>rdiv</Code> is given, it is checked that it is the right division on <Code>S</Code> corresponding
  to the multiplication <Code>mult</Code>.
</Returns>
 <Description>
<P/>
 </Description>
</ManSection>


<ManSection>
  <Func Arg="S, mult[, rdiv, ldiv]" Name="IsQuasigroupFunction" />
 <Returns><Code>true</Code> if <Code>mult</Code> is a quasigroup function on <Code>S</Code>, else returns <Code>false</Code>.  (See Subsection <Ref Subsect="Subsection_ConstructorArguments"/> for how the optional arguments are treated.) 
  If <Code>rdiv</Code> is given, it is checked that it is the right division
  on <Code>S</Code> corresponding to the multiplication <Code>mult</Code>. If <Code>ldiv</Code> is given,
  it is checked that it is the left division on <Code>S</Code> corresponding to the multiplication <Code>mult</Code>.
</Returns>
 <Description>
<P/>
 </Description>
</ManSection>


<Example><![CDATA[
gap> mult := function( x, y ) return (x+2*y) mod 4; end;
function( x, y ) ... end
gap> IsRightQuasigroupFunction( [0..3], mult );
true
gap> IsQuasigroupFunction( [0..3], mult );
false
]]></Example>


<ManSection>
  <Func Arg="S, mult[, rdiv, ldiv, one]" Name="IsLoopFunction" />
 <Returns><Code>true</Code> if <Code>mult</Code> is a loop function on <Code>S</Code>, else returns <Code>false</Code>.  (See Subsection <Ref Subsect="Subsection_ConstructorArguments"/> for how the optional arguments are treated.) 
  If <Code>rdiv</Code> is given, it is checked that it is the right division
  on <Code>S</Code> corresponding to the multiplication <Code>mult</Code>. If <Code>ldiv</Code> is given,
  it is checked that it is the left division on <Code>S</Code> corresponding to the multiplication <Code>mult</Code>.
  If <Code>one</Code> is given, it is checked that it is is the neutral element with respect to <Code>mult</Code>.
</Returns>
 <Description>
<P/>
 </Description>
</ManSection>


<Example><![CDATA[
gap> mult := \+;;
gap> rdiv := \-;;
gap> ldiv := function( x,y ) return -x+y; end;;
gap> one := Zero( GF(5) );;
gap> IsLoopFunction( GF(5), mult ); 
true
gap> IsLoopFunction( GF(5), mult, rdiv );
true
gap> IsLoopFunction( GF(5), mult, rdiv, ldiv );
true
gap> IsLoopFunction( GF(5), mult, one );
true
gap> IsLoopFunction( GF(5), mult, rdiv, one );
true
gap> IsLoopFunction( GF(5), mult, rdiv, ldiv, one );
true
gap> IsLoopFunction( GF(5), mult, ldiv ); # returns false because right division is expected before left division
false
]]></Example>


<ManSection Label="ThreeOperations">
<Heading>Multiplication, right division and left division functions</Heading>
  <Oper Arg="Q" Name="MultiplicationFunction" Label="for IsRightQuasigroup"/>
  <Oper Arg="Q" Name="RightDivisionFunction" Label="for IsRightQuasigroup"/>
  <Oper Arg="Q" Name="LeftDivisionFunction" Label="for IsQuasigroup"/>
 <Description>
<P/>
Returns, respectively, the multiplication function, right division function and left division function
 of right quasigroup <Code>Q</Code> as a &GAP; function. For the left division, <Code>Q</Code> must be a declared
 quasigroup. If the requested function is not bound, returns <Code>fail</Code>. See Section <Ref Sect="Section_IndexBased"/> for 
 more details on multiplication and division functions in index based and non-index based right quasigroups.
 </Description>
</ManSection>


<ManSection>
  <Func Arg="S, mult[, rdiv][, indexBased, checkArgs]" Name="RightQuasigroupByFunction" />
 <Returns>a right quasigroup with underlying set <Code>S</Code> and multiplication function <Code>mult</Code>.  (See Subsection <Ref Subsect="Subsection_ConstructorArguments"/> for how the optional arguments are treated.) 
  If <Code>rdiv</Code> is given, it becomes the right division function, else the right division function
  is automatically inferred from <Code>mult</Code>.
</Returns>
 <Description>
<P/>
 </Description>
</ManSection>


<ManSection>
  <Func Arg="S, mult[, rdiv, ldiv][, indexBased, checkArgs]" Name="QuasigroupByFunction" />
 <Returns>a quasigroup with underlying set <Code>S</Code> and multiplication function <Code>mult</Code>.  (See Subsection <Ref Subsect="Subsection_ConstructorArguments"/> for how the optional arguments are treated.) 
  If <Code>rdiv</Code> (resp. <Code>ldiv</Code>) is given, it is set as the right (resp. left) division function,
  else the right (resp. left) division function is automatically inferred from <Code>mult</Code>.
</Returns>
 <Description>
<P/>
 </Description>
</ManSection>


<Example><![CDATA[
gap> S := GF(5);;
gap> mult := function( x, y ) return x+2*y; end;;
gap> rdiv := function( x, y ) return x-2*y; end;;
gap> ldiv := function( x, y ) return (y-x)/2; end;;
gap> IsQuasigroupFunction( S, mult, rdiv, ldiv );
true
gap> QuasigroupByFunction( S, mult, rdiv, ldiv );
<quasigroup of size 5>
]]></Example>


<ManSection>
  <Func Arg="S, mult[, rdiv, ldiv, one][, indexBased, checkArgs]" Name="LoopByFunction" />
 <Returns>a loop with underlying set <Code>S</Code> and multiplication function <Code>mult</Code>.  (See Subsection <Ref Subsect="Subsection_ConstructorArguments"/> for how the optional arguments are treated.) 
  If <Code>rdiv</Code> (resp. <Code>ldiv</Code>) is given, it is set as the right (resp. left) division function,
  else the right (resp. left) division function is automatically inferred from <Code>mult</Code>. 
  If <Code>one</Code> is given, it is set as the neutral element, else it is automatically inferred from <Code>mult</Code>.
</Returns>
 <Description>
<P/>
 </Description>
</ManSection>


 <P/>The following constructor produces a loop of size just over 1 million near instantaneously since nothing is checked.
<Example><![CDATA[
gap> p := 1000003;;
gap> S := Difference( GF(p), [ Zero( GF( p ) ) ] );; # nonzero elements of GF(p)
gap> Q := LoopByFunction( S, \*, false, false ); # not index based, no arguments checked
<loop of size 1000002>
gap> One( Q );
lZmodpZObj( 1, 1000003 )
gap> Q.10*Q.100;
lZmodpZObj( 1000, 1000003 )
gap> Q.100/Q.10;
lZmodpZObj( 10, 1000003 )
gap> Inverse( Q.10 );
lZmodpZObj( 300001, 1000003 )
]]></Example>


</Section>


<Section Label="Chapter_Constructors_Section_Constructors_by_right_section">
<Heading>Constructors by right section</Heading>

 <P/>For a right quasigroup <Math>(Q,\cdot)</Math>, the <Index>right section</Index><Emph>right section</Emph>
 is the ordered tuple <Math>R_Q = (R_x:x\in Q)</Math> of right translations of <Math>Q</Math>. Since <Math>xy = R_y(x)</Math>,
 the multiplication in <Math>(Q,\cdot)</Math> can be fully reconstructed from its right section.
 <P/>A right section <Math>(Q,R_Q)</Math> is a <Index>quasigroup right section</Index>
 <Emph>quasigroup right section</Emph> (resp. <Index>loop right section</Index>
 <Emph> loop right section</Emph>) if the corresponding right quasigroup is a quasigroup (resp. loop).
 <P/>In &RightQuasigroups;, a right section consists of the underlying set <Math>S</Math> of size <Math>n</Math>
 and an ordered collection of <Math>n</Math> group elements that act on <Math>S</Math>. Implicit
 right sections are also allowed, that is, a set <Math>S</Math> of size <Math>n</Math> and an ordered
 collection of permutations on <Math>[1..n]</Math>, in which case <Math>x^f=y</Math> iff <Math>x</Math> is the <Math>i</Math>th 
 element of <Math>S</Math>, <Math>i^f=j</Math> and <Math>y</Math> is the <Math>j</Math>th element of <Math>S</Math>.
<ManSection Label="AutoDoc_generated_group10">
<Heading>Testing right sections</Heading>
  <Oper Arg="S, section" Name="IsRightSection" Label="for IsCollection, IsCollection"/>
  <Oper Arg="S, section" Name="IsQuasigroupRightSection" Label="for IsCollection, IsCollection"/>
  <Oper Arg="S, section" Name="IsLoopRightSection" Label="for IsCollection, IsCollection"/>
 <Returns><Code>true</Code> if <Code>section</Code> is a right section (resp. quasigroup right section,  loop right section) on <Code>S</Code>, else returns <Code>false</Code>.
</Returns>
 <Description>
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group11">
<Heading>Constructing right quasigroups, quasigroups and loops by right section</Heading>
  <Func Arg="S, section[, indexBased, checkArgs]" Name="RightQuasigroupByRightSection" />
  <Func Arg="S, section[, indexBased, checkArgs]" Name="QuasigroupByRightSection" />
  <Func Arg="S, section[, indexBased, checkArgs]" Name="LoopByRightSection" />
 <Returns>a right quasigroup, quasigroup or loop on <Code>S</Code> with right section <Code>section</Code>, respectively.  See Section <Ref Sect="Section_OptionalArguments"/> for the optional arguments.
</Returns>
 <Description>
<P/>
 </Description>
</ManSection>


 <P/>Here is an example of a right quasigroup constructed by a right section consisting of permutations.
<Example><![CDATA[
gap> section := [ (), (1,2,3,4), (), (1,3)(2,4) ];;
gap> IsRightSection( [1..4], section );
true
gap> IsRightSection( [1..3], section );
false
gap> IsRightSection( "abcd", section ); # implicit permutation action on the set ['a','b','c','d']
true
gap> IsQuasigroupRightSection( [1..4], section );
false
gap> Q := RightQuasigroupByRightSection( [1..4], section );
<right quasigroup of size 4>
gap> Q[3]*Q[2];
r4
gap> RightQuasigroupByRightSection( "abcd", section );
<right quasigroup of size 4>
gap> Elements( last );
[ r'a', r'b', r'c', r'd' ]
]]></Example>


 <P/>Here is an example of a right quasigroup constructed by a right section consisting of
 group elements acting on the underlying set, in this case of matrices acting on <Code>GF(2)^2</Code>.
<Example><![CDATA[
gap> i := Z(2)*[[1,0],[0,1]];;
gap> m := Z(2)*[[1,1],[0,1]];;
gap> section := [m,m,i,i];;
gap> IsRightSection( GF(2)^2, section );
true
gap> Q := RightQuasigroupByRightSection( GF(2)^2, section );
<right quasigroup of size 4>
gap> Q.1;
r[ 0*Z(2), 0*Z(2) ]
]]></Example>


 <P/>We conclude with an example of a loop constructed by a right section.
 Note that the neutral element is not the first element of the underlying set.
<Example><![CDATA[
gap> section := [(1,2),()];;
gap> IsQuasigroupRightSection( [1,2], section );
true
gap> QuasigroupByRightSection( [1,2], section );
<right quasigroup of size 2>
gap> IsLoopRightSection( [1,2], section );
true
gap> LoopByRightSection( [1,2], section );
<loop of size 2>
gap> One( last );
l2
]]></Example>


</Section>


<Section Label="Chapter_Constructors_Section_Constructors_by_right_folder_transversal">
<Heading>Constructors by right folder (transversal)</Heading>

 <P/>The triple <Math>(G,H,T)</Math> is a <Index>right folder</Index><Emph>right folder</Emph>
 if <Math>G</Math> is a group, <Math>H</Math> is a subgroup of <Math>G</Math> and <Math>T</Math> is a right transversal to <Math>H</Math> in <Math>G</Math>.
 <P/>Given a right folder <Math>(G,H,T)</Math>, we can define a magma <Math>(T,\circ)</Math>
 by setting <Math>x\circ y = z</Math> iff <Math>xy\in Hz</Math>, for <Math>x,y,z\in T</Math>. Then <Math>(T,\circ)</Math>
 is always a right quasigroup. Not every right quasigroup is obtained in this way.
 <P/>The right folder <Math>(G,H,T)</Math> is a <Index>quasigroup right folder</Index><Emph>quasigroup
 right folder</Emph> (resp. <Index>loop right folder</Index><Emph>loop right folder</Emph>) if
 <Math>(T,\circ)</Math> is a quasigroup (resp. loop). Group-theoretically, <Math>(G,H,T)</Math> is a quasigroup
 right folder iff <Math>T</Math> is a right transversal to every conjugate <Math>H^g</Math> of <Math>H</Math> in <Math>G</Math>. Furthermore,
 a quasigroup right folder <Math>(G,H,T)</Math> is a loop right folder iff <Math>T</Math> intersects the
 core of <Math>H</Math> in <Math>G</Math>, i.e., the normal subgroup <Math>\bigcap_{g\in G}H^g</Math>.
 <P/>Up to isomorphism, every quasigroup (resp. loop) is obtained as <Math>(T,\circ)</Math> for some
 quasigroup (resp. loop) folder <Math>(G,H,T)</Math>.
 <P/>In &GAP;, right transversals are records that carry within them the enveloping group
 <Math>G</Math> and the subgroup <Math>H</Math>. (If <Code>T</Code> is a right transversal then <Code>T!.group</Code> is the enveloping group
 and <Code>T!.subgroup</Code> is the subgroup.) It therefore suffices to provide the right transversal <Math>T</Math>
 as an argument of functions that require the folder <Math>(G,H,T)</Math>.
<ManSection Label="AutoDoc_generated_group12">
<Heading>Checking right folders</Heading>
  <Oper Arg="T" Name="IsRightFolder" Label="for IsRightTransversal"/>
  <Oper Arg="T" Name="IsQuasigroupRightFolder" Label="for IsRightTransversal"/>
  <Oper Arg="T" Name="IsLoopRightFolder" Label="for IsRightTransversal"/>
 <Returns><Code>true</Code> if the right transversal <Code>T</Code> is a right folder  (resp. quasigroup right folder, loop right folder),
  else returns <Code>false</Code>. Note that there is nothing to check in the right quasigroup case 
  when the operation always returns <Code>true</Code>.
</Returns>
 <Description>
<P/>
 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group13">
<Heading>Creating right quasigroups, quasigroups and loops by right folders</Heading>
  <Func Arg="T[, indexBased, checkArgs]" Name="RightQuasigroupByRightFolder" />
  <Func Arg="T[, indexBased, checkArgs]" Name="QuasigroupByRightFolder" />
  <Func Arg="T[, indexBased, checkArgs]" Name="LoopByRightFolder" />
 <Returns>a right quasigroup (resp. quasigroup or loop) from the right folder  (resp. quasigroup right folder, loop right folder) <Code>T</Code>.
  See Section <Ref Sect="Section_OptionalArguments"/> for the optional arguments.
</Returns>
 <Description>
<P/>
 </Description>
</ManSection>


 <P/>Here is an example of a right quasigroup constructed from a right folder.
<Example><![CDATA[
gap> G := SymmetricGroup( 6 );;
gap> H := Subgroup( G, [(1,2,3)] );;
gap> T := RightTransversal( G, H );;
gap> IsRightFolder( T );
true
gap> IsQuasigroupRightFolder( T );
false
gap> RightQuasigroupByRightFolder( T );
<right quasigroup of size 240>
]]></Example>


 <P/>And here is an example of a loop constructed from a (trivial) right folder.
<Example><![CDATA[
gap> G := SymmetricGroup( 2 );;
gap> H := Subgroup( G, [()] );;
gap> T := RightTransversal( G, H );;
gap> IsQuasigroupRightFolder( T );
true
gap> IsLoopRightFolder( T );
true
gap> QuasigroupByRightFolder( T );
<quasigroup of size 2>
gap> LoopByRightFolder( T );
<loop of size 2>
gap> Elements( last );
[ l(), l(1,2) ]
]]></Example>


</Section>


<Section Label="Chapter_Constructors_Section_Constructors_for_special_types_of_right_quasigroups">
<Heading>Constructors for special types of right quasigroups</Heading>

 Here we collect a few constructors for special types of right quasigroups.
<ManSection>
  <Func Arg="S[, indexBased, checkArgs]" Name="ProjectionRightQuasigroup" />
 <Returns>the projection right quasigroup on the set <Code>S</Code>, that is, a magma on <Code>S</Code> with mutliplication <Code>x*y=x</Code>.
</Returns>
 <Description>
<P/>
 </Description>
</ManSection>


<Example><![CDATA[
gap> ProjectionRightQuasigroup( [1..1000], false );; # 16 ms to construct
gap> Q := ProjectionRightQuasigroup( [1..1000] );; # 375 ms to construct
gap> Q.123*Q.456;
r123
]]></Example>


<ManSection>
  <Func Arg="G[, indexBased, checkArgs]" Name="RightCoreOfGroup" />
 <Returns>the right core of a group <Code>G</Code>, that is, the right quasigroup on <Code>G</Code>  with multiplication given by <Math>x*y = yx^{-1}y</Math>.
</Returns>
 <Description>
<P/>
 </Description>
</ManSection>


<Example><![CDATA[
gap> G := AlternatingGroup( 5 );
gap> Q := RightCoreOfGroup( G );
<right quasigroup of size 60>
gap> Q[(1,2,3)]*Q[(1,2,3,4,5)] = Q[(1,2,3)*(1,2,3,4,5)^(-1)*(1,2,3)];
true
]]></Example>


</Section>


 <P/>In this chapter we collect constructor methods for right quasigroups.
</Chapter>

