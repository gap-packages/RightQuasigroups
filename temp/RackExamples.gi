# INTERFACE FOR THE GAP LIBRARY OF RACKS AND QUANDLES
# Petr Vojtechovsky
# 2018
# updated 7/30/2018
# -------------------------------------------------------------------

# This is an interface for the GAP library of racks and quandles
# of small orders.

# The library contains:
#   - all racks of order <= 11
#   - all quandles of order <= 12 up to isomorphism
#   - all non-2-reductive racks of orders 12, 13 up to isomorphism
#   - all non-2-reductive quandles of orders 13 up to isomorphism

#====================================================================
# INSTALLATION AND USAGE:
# 1) copy the data files
#       - racks_of_order_n.txt (for n in [1..13])
#       - quandles_of_order_n.txt (for n in [1..13])
#    into some folder.
# 2) start GAP
# 3) read this file into GAP
# 4) if the data files are located in a folder from which GAP
#    automatically reads files, go to 5), otherwise call
#       RQ_SetPath( path );
#    where <path> is the path to the folder containing the above
#    data files.
# 5) to construct the kth rack of order n, call
#       RQ_Rack( n, k );
#    to construct the kth quandle of order n, call
#       RQ_Quandle( n, k );
#====================================================================

# NOTES:
#
# a) A rack or quandle of order n is returned as an n-tuple
#   of permutations of S_n corresponding to left translations.
#
# b) The library is organized as follows:
#
# - for given order n, the data is contained in the files
#       racks_of_order_n.txt
#       quandles_of_order_n.txt
#   and these files are read whenever RQ_Rack(n,k)
#   or RQ_Quandle(n,k) are called for the first time
# - the global variables
#       RQ_rack_groups, RQ_quandle_groups,
#       RQ_rack_ids, RQ_quandle_ids
#   contain all information about groups and ids necessary to
#   construct the racks and quandles. For instance,
#       RQ_rack_groups[5][3]
#   contains the generators of the 3rd group for racks of order 5
# - the ids are stored in a very compact form as follows:
#       * for given n and g, the list
#           RQ_rack_ids[n][g]
#         contains ids of racks of order n whose left multiplication
#         group is generated by RQ_rack_groups[n][g]
#       * RQ_rack_ids[n][g][t] is the actual id if and only if
#         t is congruent to 1 modulo 100. For other t, the id
#         is determined by summing up the values
#           RQ_rack_ids[n][g][x],
#         where x ranges from the nearest smaller index congruent
#         to 1 modulo 100 all the way to t. Moreover, if
#         the value RQ_rack_ids[n][g][x] is not bound, it is
#         understood to be equal to 1.
# - the id of the kth rack/quandle determines the rack/quandle as
#   follows: Let G be the corresponding group, let m be the orbits of
#   G and let x_1, ..., x_m be orbit representatives. Let
#       X = \prod_{i=1}^m C_G(G_{x_i})
#   in the case of racks, and
#       X = \prod_{i=1}^m Z(G_{x_i})
#   in the case of quandles. Thus X is the space of rack/quandle
#   folders for G. The integer id then corresponds to a unique
#   element of X, the conversion being handled by the method
#       RQ_IntToCounter
#   below. This element corresponds to the left translations by the
#   representatives x_i. The remaining left translations are
#   determined as usual: if g is an element of G that maps x_i to y,
#   then (L_{x_i})^g is the left translation by L_y.
#
# c) The library is optimized for speed as follows:
#   The data required for the lastly constructed rack or
#   quandle is stored in a global variable. When the next
#   rack of quandle is being constructed, the data is reused
#   whenever possible.
#
# d) The library is not optimized in the following sense.
#   Every quandle is a rack. Every rack/quandle of order n
#   embeds into a rack/quandle of order n+1. It is therefore
#   possible to obtain all racks and quandles of order <=n
#   from the library or racks of order n. However, this library
#   separately gives data for racks and quandles of all small orders.

# global variable holding all data, methods, etc., for the library
LRQ := rec();

# path to the folder containing data files (should end with /)
RQ_path := "";

RQ_SetPath := function( path )
    RQ_path := path;
    return true;
end;

# RQ_IntToCounter(i,ls)
# Example: Suppose that ls = [3,2]. Then possible counter states are
# [1,1], [1,2], [2,1], [2,2], [3,1], [3,2], in this order.
# This method returns the ith element on this list.

RQ_IntToCounter := function( i, ls )
    local m, counter, j;
    m := Length( ls );
    i := i-1;
    counter := 0*[1..m];
    for j in [1..m] do
        counter[ m-j+1 ] := i mod ls[ m-j+1 ];
        i := (i - counter[ m-j+1 ])/ls[ m-j+1 ];
    od;
    counter := counter + 1; # adds 1 in all slots
    return counter;
end;

# data arrays that will be populated from data files
RQ_rack_groups := [];
RQ_rack_ids := [];
RQ_quandle_groups := [];
RQ_quandle_ids := [];

# info about previous rack and quandle constructed, to speed up the library
RQ_rack_previous := rec( G := "", orbs := "", reps := "", m := "", stabs := "", folder := "", trans := "" );
RQ_quandle_previous := rec( G := "", orbs := "", reps := "", m := "", stabs := "", folder := "", trans := "" );

# RQ_Algebra( n, k, rack_or_quandle )
# technical method, returns the kth rack/quandle of order n
# users should use RQ_Rack(n,k) and RQ_Quandle(n,k)

RQ_Algebra := function( n, k, rack_or_quandle )

    local groups, ids, previous, group_id, sum, G, id, i, q, L0, t;

    if rack_or_quandle = "rack" then
        groups := RQ_rack_groups;
        ids := RQ_rack_ids;
        previous := RQ_rack_previous;
    else
        groups := RQ_quandle_groups;
        ids := RQ_quandle_ids;
        previous := RQ_quandle_previous;
    fi;

    # load data file if needed
    if not IsBound( groups[ n ] ) then
        Info( InfoRightQuasigroups, 1, " - reading data file " );
        Read( Concatenation( RQ_path, rack_or_quandle, "s_of_order_", String(n), ".txt" ) );
    fi;

    # construct relevant group
    group_id := 1;
    sum := 0;
    while sum + Length( ids[n][group_id] ) < k do
        sum := sum + Length( ids[n][group_id] );
        group_id := group_id + 1;
        if group_id > Length( groups[n] ) then
            Error("There are less than ", k, " ", rack_or_quandle, "s of order ", n, " in the database.");
        fi;
    od;
    G := Group( groups[ n ][ group_id ] );

    # construct relevant id
    k := k - sum; # relative k
    id := ids[n][group_id][ k-1 - ((k-1) mod 100) + 1 ];
    for i in [k-1 - ((k-1) mod 100) + 2 .. k] do
        if not IsBound( ids[n][group_id][i] ) then
            id := id + 1;
        else
            id := id + ids[n][group_id][i];
        fi;
    od;

    if previous.G <> G then # new group, initialize group parameters
        previous.G := G;
        previous.orbs := Orbits( G, [1..n] );
        previous.reps := List( previous.orbs, O -> O[1] );
        previous.m := Length( previous.reps ); # number of orbits
        previous.stabs := List( [1..previous.m], i -> Stabilizer( G, previous.reps[i] ) );
        if rack_or_quandle = "rack" then
            previous.folder := List( [1..previous.m], i -> Set( Elements( Centralizer( G, previous.stabs[i] ) ) ) );
        else
            previous.folder := List( [1..previous.m], i -> Set( Elements( Center( previous.stabs[i] ) ) ) );
        fi;
        previous.trans := List( [1..previous.m], i -> Set( Elements( RightTransversal( G, previous.stabs[i] ) ) ) );
    fi;

    # construct and return the algebra
    id := RQ_IntToCounter( id, List( previous.folder, Length ) );
    q := []; # the quandle/rack, represented as a list of n left translations
    for i in [1..previous.m] do
        L0 := previous.folder[i][ id[i] ]; # left translation for orbit representative
        for t in previous.trans[ i ] do
            q[ previous.reps[i]^t ] := L0^t;
        od;
    od;
    return q;

end;

# RQ_Rack( n, k )
# returns the kth rack of order n up to isomorphism

RQ_Rack := function( n, k )
    return RQ_Algebra( n, k, "rack" );
end;

# RQ_Quandle( n, k )
# returns the kth quandle of order n up to isomorphism

RQ_Quandle := function( n, k )
    return RQ_Algebra( n, k, "quandle" );
end;

# RQ_IsRack(q) and RQ_IsQuandle(q)
# returns true if q is a rack or quandle, respectively
# Note: This is not required for the library to work.

RQ_IsRack := function( q )
    local n, x, y, z, xy;
    n := Length(q);
    # checking left quasigroup property
    if not ForAll( q, row -> IsPerm(row) and IsSubset( [1..n], MovedPoints(row) ) ) then
        return false;
    fi;
    # checking left self-distributivity
    for x in [1..n] do for y in [1..n] do
        xy := y^q[x];
        for z in [1..n] do
            if not (z^q[y])^q[x] = (z^q[x])^q[xy] then
                return false;
            fi;
        od;
    od; od;
    return true;
end;

RQ_IsQuandle := function( q )
    local n;
    n := Length(q);
    return RQ_IsRack(q) and ForAll( [1..n], i -> i^(q[i])=i );
end;
