# testing multiplicative closure
gap> Q := QuasigroupByFunction([0..9999], function(x,y) return (x+y) mod 10000; end, false, false );;
gap> x := Q[9495];;
gap> S := Set([ Q.216, Q.9685, Q.5613, Q.616, Q.6860, Q.5997, Q.175, Q.6377, Q.3407, Q.7811 ]);
gap> Size(Magma(x)); time;
2000
28828
gap> Size(Magma(S)); time;
10000
590859

MultiplicativeClosure := function( gens )
	local added, elms, newly_added, x, y, u, v;
	added := ShallowCopy(gens);
	elms := ShallowCopy(gens);
	while not IsEmpty( added ) do
		newly_added := [];
		for x in elms do for y in added do
			u := x*y; 
			if not u in elms then 
				AddSet( newly_added, u );
			fi;
			v := y*x;
			if not u=v and not v in elms then
				AddSet( newly_added, v );
			fi;	
		od; od;
		added := ShallowCopy( newly_added );
		elms := Union( elms, added );
	od;
	return elms;
end;

gap> Size(MultiplicativeClosure( [x] )); time;
2000
7734 (other run 7468)
gap> Size(MultiplicativeClosure( S )); time;
10000
272610

MultiplicativeClosure := function( gens )
	local added, elms, newly_added, x, y, u, v;
	added := ShallowCopy(gens);
	elms := ShallowCopy(gens);
	while not IsEmpty( added ) do
		newly_added := [];
		for x in elms do for y in added do
			u := x*y; 
			if not u in elms then 
				AddSet( newly_added, u );
			fi;
			v := y*x;
			if not u=v and not v in elms then
				AddSet( newly_added, v );
			fi;	
		od; od;
		for x in added do for y in added do
			u := x*y; 
			if not u in elms then 
				AddSet( newly_added, u );
			fi;
			v := y*x;
			if not u=v and not v in elms then
				AddSet( newly_added, v );
			fi;	
		od; od;
		added := ShallowCopy( newly_added );
		elms := Union( elms, added );
	od;
	return elms;
end;

gap> Size(MultiplicativeClosure( [x] )); time;
2000
11813

MultiplicativeClosure := function( gens )
	local elms, new_elms, old_elms, found, x, y, u, v, z;
	elms := ShallowCopy(gens);	
	new_elms := ShallowCopy( gens );
	old_elms := [];
	while not IsEmpty( new_elms ) do
		found := [];
		for x in old_elms do for y in new_elms do
			u := x*y; v := y*x; 
			if not u in elms then AddSet( found, u ); fi;
			if u<>v and not v in elms then AddSet( found, v ); fi; # the test u<>v helps in commutative situations
		od; od;
		for x in new_elms do for y in new_elms do
			u := x*y; 
			if not u in elms then AddSet( found, u ); fi;
		od; od;
		old_elms := ShallowCopy( elms );
		new_elms := ShallowCopy( found );
		elms := Union( old_elms, new_elms );
	od;
	return elms;
end;

gap> Size(MultiplicativeClosure( [x] )); time;
2000
6906

MultiplicativeClosure := function( gens )
	local elms, new_elms, old_elms, found, x, y, u, v;
	elms := ShallowCopy(gens);
	new_elms := ShallowCopy( gens );
	old_elms := [];
	while not IsEmpty( new_elms ) do
		found := [];
		for x in old_elms do for y in new_elms do
			u := x*y; v := y*x; 
			AddSet( found, u );
			if u<>v then AddSet( found, v ); fi;
		od; od;
		for x in new_elms do for y in new_elms do
			AddSet( found, x*y );
		od; od;
		old_elms := ShallowCopy( elms );
		new_elms := Difference( found, elms );
		elms := Union( old_elms, new_elms );
	od;
	return elms;
end;

gap> Size(MultiplicativeClosure( [x] )); time;
2000
6125
gap> Size(MultiplicativeClosure( S )); time;
10000
216094



