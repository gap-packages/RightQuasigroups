# RightQuasigroups, chapter 3
#
# DO NOT EDIT THIS FILE - EDIT EXAMPLES IN THE SOURCE INSTEAD!
#
# This file has been generated by AutoDoc. It contains examples extracted from
# the package documentation. Each example is preceded by a comment which gives
# the name of a GAPDoc XML file and a line range from which the example were
# taken. Note that the XML file in turn may have been generated by AutoDoc
# from some other input.
#
gap> START_TEST( "rightquasigroups03.tst");

# doc/_Chapter_Direct_products_subalgebras_and_factor_algebras.xml:20-29
gap> G := Group((1,2));;
gap> Q := ProjectionRightQuasigroup( [1..3] );;
gap> D := DirectProduct( G, Q );
<right quasigroup of size 6>
gap> Elements( D );
[ r[ (), r1 ], r[ (), r2 ], r[ (), r3 ], r[ (1,2), r1 ], r[ (1,2), r2 ], r[ (1,2), r3 ] ]
gap> DirectProduct( Q, G, Q );
<right quasigroup of size 18>

# doc/_Chapter_Direct_products_subalgebras_and_factor_algebras.xml:54-66
gap> Q := QuasigroupByFunction( GF(3), \- );;
gap> OQ := OppositeQuasigroup( Q );
<quasigroup of size 3>
gap> Display( MultiplicationTable( Q ) );
[ [  1,  3,  2 ],
  [  2,  1,  3 ],
  [  3,  2,  1 ] ]
gap> Display( MultiplicationTable( OQ ) );
[ [  1,  2,  3 ],
  [  3,  1,  2 ],
  [  2,  3,  1 ] ]

# doc/_Chapter_Direct_products_subalgebras_and_factor_algebras.xml:119-144
gap> Q := LoopByFunction([0..7],function(x,y) return (x+y) mod 8; end);;
gap> S := Subrightquasigroup( Q, [4] ); # inherits loop property from parent
<loop of size 2>
gap> [ IsSubrightquasigroup( Q, S ), IsSubquasigroup( Q, S ), IsSubloop( Q, S ) ];
[ true, true, true ]
gap> Elements( S ); # note indexing of elements here and below
[ l0, l4 ]
gap> Elements( S )[ 2 ]; # the 2nd element of S
l4
gap> S.2; # the 2nd element of Q, the parent of S
l1
gap> S[4]; # the element of parent Q corresponding to the given element of the underlying set
l4 
gap> Display( CayleyTable( S ) );
[ [  0,  4 ],
  [  4,  0 ] ]
gap> RightTranslation( Q, Q[4] ); # a permutation of the index set of Q
(1,5)(2,6)(3,7)(4,8)
gap> RightTranslation( S, S[4] ); # a permutation of the index set of S
(1,5)
gap> Subquasigroup( Q, [4] );
<loop of size 2>
gap> Subloop( Q, [4] );
<loop of size 2>

# doc/_Chapter_Direct_products_subalgebras_and_factor_algebras.xml:160-167
gap> AllSubloops( AsLoop( SymmetricGroup( 3 ) ) );
[ <associative loop of size 1>, <associative loop of size 2>, <associative loop of size 2>,
  <associative loop of size 3>, <associative loop of size 2>, <associative loop of size 6> ]
gap> P := ProjectionRightQuasigroup( [1..2] );; 
gap> AllSubrightquasigroups( P ); # every nonempty subset is a subrightquasigroup
[ <associative quandle of size 1>, <associative quandle of size 1>, <associative quandle of size 2> ]

# doc/_Chapter_Direct_products_subalgebras_and_factor_algebras.xml:197-206
gap> P := ProjectionRightQuasigroup( 3 ); # this is in fact an associative quandle
<associative quandle of size 3>
gap> S := Subrightquasigroup( P, [1,2] );
<associative quandle quasigroup of size 2>
gap> RightCosets( P, S ); # there is a single right coset of S in P
[ [ r1, r2 ] ]
gap> RightTransversal( P, S );
[ r1 ]

# doc/_Chapter_Direct_products_subalgebras_and_factor_algebras.xml:280-292
gap> P := ProjectionRightQuasigroup( 10 );;
gap> A := Subrightquasigroup( P, [1..4] );;
gap> B := Subrightquasigroup( P, [3..7] );;
gap> Intersection( A, B );
<associative quandle of size 2>
gap> Elements( last );
[ r3, r4 ]
gap> Join( A, B );
<associative quandle of size 7>
gap> Elements( last );
[ r1, r2, r3, r4, r5, r6, r7 ]

# doc/_Chapter_Direct_products_subalgebras_and_factor_algebras.xml:347-356
gap> Q := QuasigroupByFunction( [0..3], function(x,y) return (x-y) mod 4; end );;
gap> C := EquivalenceRelationByPartition( Q, [ [Q[0],Q[2]], [Q[1],Q[3]] ] );
<equivalence relation on <quasigroup of size 4 on 0, 1, 2, 3> >
gap> IsQuasigroupCongruence( C );
true
gap> D := EquivalenceRelationByPartition( Q, [ [Q[0],Q[1],Q[2]], [Q[3]] ] );;
gap> IsQuasigroupCongruence( D );
false

# doc/_Chapter_Direct_products_subalgebras_and_factor_algebras.xml:375-384
gap> Q := QuasigroupByFunction( GF(27), \- );
gap> C := QuasigroupCongruenceByPartition( Q, [ [ Q.1, Q.2, Q.3 ], [ Q.4, Q.5 ] ] );; merge Q.1, Q.2, Q.3 and also Q.4, Q.5
gap> List( EquivalenceClasses( C ), Size );
[ 9, 9, 9 ]
gap> G := AsLoop( SymmetricGroup( 5 ) );;
gap> C := LoopCongruenceByPartition( G, [ [ G[()], G[(1,2,3)] ] ] );; # merge (), (1,2,3)
gap> List( EquivalenceClasses( C ), Size );
[ 60, 60 ]

# doc/_Chapter_Direct_products_subalgebras_and_factor_algebras.xml:402-410
gap> Q := RightQuasigroupByFunction([0..7], function(x,y) return (x+2*y) mod 8; end );;
gap> C := RightQuasigroupCongruenceByPairs( Q, [ [ Q[0],Q[2] ] ] );; # merge 0, 2
gap> List( EquivalenceClasses( C ), Elements );
[ [ r0, r2, r4, r6 ], [ r1, r5 ], [ r3, r7 ] ]
gap> C := RightQuasigroupCongruenceByPairs( Q, [ [ Q[0],Q[2] ], [ Q[0], Q[1] ] ] );; # merge 0, 2 and also 0, 1
gap> List( EquivalenceClasses( C ), Elements );
[ [ r0, r1, r2, r3, r4, r5, r6, r7 ] ]

# doc/_Chapter_Direct_products_subalgebras_and_factor_algebras.xml:478-506
gap> # right quasigroup example
gap> R := RightQuasigroupByCayleyTable( [[2,2,1,1],[3,1,2,2],[4,3,3,3],[1,4,4,4]] );; 
gap> RMlt := RightMultiplicationGroup( R );
Group([ (1,2,3,4), (1,2) ])
gap> AllRightQuasigroupCongruences( R );
[ <equivalence relation on <right quasigroup of size 4 on 1, 2, 3, 4> >,
  <equivalence relation on <right quasigroup of size 4 on 1, 2, 3, 4> > ]
gap> IsSimpleRightQuasigroup( R ); # IsSimple( R ) is also supported
true
gap> # quasigroup example
gap> Q := QuasigroupByFunction( [0..3], function(x,y) return (x-y) mod 4; end );;
gap> congruences := AllQuasigroupCongruences( Q );;
gap> List( congruences, EquivalenceClasses );
[ [ {q0}, {q1}, {q2}, {q3} ], [ {q0}, {q1} ], [ {q0} ] ]
gap> List( EquivalenceClasses( congruences[ 2 ] ), Elements );
[ [ q0, q2 ], [ q1, q3 ] ]
gap> IsSimpleQuasigroup( Q ); # IsSimple( Q ) is also supported
false
gap> # loop example
gap> L := AsLoop( Group((1,2,3,4)) );;
gap> AllNormalSubloops( L );
[ <associative loop of size 1>, <associative loop of size 2>, <associative loop of size 4> ]
gap> IsSimpleLoop( L ); # IsSimple( L ) is also supported
false
gap> S := Subloop(  L, [ (1,3)(2,4) ] );;
gap> IsNormal( L, S );
true 

# doc/_Chapter_Direct_products_subalgebras_and_factor_algebras.xml:548-565
gap> Q := ProjectionRightQuasigroup( 6 );;
gap> C := EquivalenceRelationByPartition( Q, [[Q.1,Q.2],[Q.3,Q.4,Q.5],[Q.6]] );;
gap> [ IsRightQuasigroupCongruence( C ), IsQuasigroupCongruence( C ), IsLoopCongruence( C ) ];
[ true, false, false ]
gap> F := Q/C;
<associative quandle of size 3>
gap> Elements( F ); # the inner "r" comes from Q, the outer "r" from F.
[ r{r1}, r{r3}, r{r6} ]
gap> H := FactorRightQuasigroup( C, ConstructorStyle( false, false ) ); # non-index based version is supported (but not for /)
<associative quandle of size 3>
gap> HasMultiplicationTable( H );
false
gap> H.1*H.2;
r{r1}
gap> CayleyTable( H );
[ [ {r1}, {r1}, {r1} ], [ {r3}, {r3}, {r3} ], [ {r6}, {r6}, {r6} ] ]

# doc/_Chapter_Direct_products_subalgebras_and_factor_algebras.xml:579-591
gap> DotProduct := function( x, y ) return Sum( [1..Length(x)], i -> x[i]*y[i] ); end;;
gap> CrossProduct := function( x, y ) return [ x[2]*y[3]-x[3]*y[2], x[3]*y[1]-x[1]*y[3], x[1]*y[2]-x[2]*y[1] ]; end;;
gap> PaigeNorm := function( x ) return x[1]*x[8] - DotProduct( x{[2,3,4]},x{[5,6,7]} ); end;;
gap> PaigeMult := function( x, y )
> local a, b, c, d;
> a := x[1]*y[1] + DotProduct(x{[2,3,4]},y{[5,6,7]});
> b := x[1]*y{[2,3,4]} + x{[2,3,4]}*y[8] - CrossProduct(x{[5,6,7]},y{[5,6,7]});
> c := x{[5,6,7]}*y[1] + x[8]*y{[5,6,7]} + CrossProduct(x{[2,3,4]},y{[2,3,4]});
> d := DotProduct(x{[5,6,7]},y{[2,3,4]})+x[8]*y[8];
> return Concatenation( [a], b, c, [d] );
> end;;

# doc/_Chapter_Direct_products_subalgebras_and_factor_algebras.xml:596-601
gap> F := GF(2);;
gap> S := Filtered( F^8, x -> PaigeNorm( x ) = One( F ) );;
gap> P := LoopByFunction( S, PaigeMult, ConstructorStyle( true, true ) ); 
<loop of size 120>

# doc/_Chapter_Direct_products_subalgebras_and_factor_algebras.xml:606-614
gap> n := 3;; # any prime power works but it will be very slow
gap> F := GF(n);;
gap> S := Filtered( F^8, x -> PaigeNorm( x ) = One( F ) );;
gap> M := LoopByFunction( S, PaigeMult, ConstructorStyle( false, false ) );;
gap> C := EquivalenceRelationByPartition( M, Set( S, x -> Set( [ M[x], M[-x] ] ) ) );; # factoring out +/- one
gap> P := FactorLoop( C, ConstructorStyle( false, false ) ); # 2000 ms
<loop of size 1080>

# doc/_Chapter_Direct_products_subalgebras_and_factor_algebras.xml:618-625
gap> n := 3;; F := GF(n);; S := Filtered( F^8, x -> PaigeNorm( x ) = One( F ) );;
gap> M := LoopByFunction( S, PaigeMult, ConstructorStyle( false, false ) );;
gap> one := [ Z(n)^0, 0*Z(n), 0*Z(n), 0*Z(n), 0*Z(n), 0*Z(n), 0*Z(n), Z(n)^0 ];;
gap> N := Subloop( M, [-one] );;
gap> P := FactorLoop( M, N, ConstructorStyle( false, false ) ); # 2000 ms, it takes a while to find the neutral element
<loop of size 1080>

# doc/_Chapter_Direct_products_subalgebras_and_factor_algebras.xml:634-650
gap> F := GF( 5 );;
gap> FA := [ One(F), Z(5) ];; # so F^* is a disjoint union of FA and -FA
gap> ModifiedPaigeMult := function( x, y )
> local a, b, c, d, e;
> a := x[1]*y[1] + DotProduct(x{[2,3,4]},y{[5,6,7]});
> b := x[1]*y{[2,3,4]} + x{[2,3,4]}*y[8] - CrossProduct(x{[5,6,7]},y{[5,6,7]});
> c := x{[5,6,7]}*y[1] + x[8]*y{[5,6,7]} + CrossProduct(x{[2,3,4]},y{[2,3,4]});
> d := DotProduct(x{[5,6,7]},y{[2,3,4]})+x[8]*y[8];
> e := Concatenation( [a], b, c, [d] );
> if not First( e, x -> x <> Zero( F ) ) in FA then e := -e ; fi;
> return e;
> end;;
gap> A := Filtered( F^8, x -> PaigeNorm( x ) = One( F ) and First( x, y -> y <> Zero( F ) ) in FA );;
gap> M := LoopByFunction( A, ModifiedPaigeMult, ConstructorStyle( false, false ) );
<loop of size 39000>

#
gap> STOP_TEST("rightquasigroups03.tst", 1 );
# RightQuasigroups, chapter 3
#
# DO NOT EDIT THIS FILE - EDIT EXAMPLES IN THE SOURCE INSTEAD!
#
# This file has been generated by AutoDoc. It contains examples extracted from
# the package documentation. Each example is preceded by a comment which gives
# the name of a GAPDoc XML file and a line range from which the example were
# taken. Note that the XML file in turn may have been generated by AutoDoc
# from some other input.
#
gap> START_TEST( "rightquasigroups03.tst");

# doc/_Chapter_Direct_products_subalgebras_and_factor_algebras.xml:20-29
gap> G := Group((1,2));;
gap> Q := ProjectionRightQuasigroup( [1..3] );;
gap> D := DirectProduct( G, Q );
<right quasigroup of size 6>
gap> Elements( D );
[ r[ (), r1 ], r[ (), r2 ], r[ (), r3 ], r[ (1,2), r1 ], r[ (1,2), r2 ], r[ (1,2), r3 ] ]
gap> DirectProduct( Q, G, Q );
<right quasigroup of size 18>

# doc/_Chapter_Direct_products_subalgebras_and_factor_algebras.xml:54-66
gap> Q := QuasigroupByFunction( GF(3), \- );;
gap> OQ := OppositeQuasigroup( Q );
<quasigroup of size 3>
gap> Display( MultiplicationTable( Q ) );
[ [  1,  3,  2 ],
  [  2,  1,  3 ],
  [  3,  2,  1 ] ]
gap> Display( MultiplicationTable( OQ ) );
[ [  1,  2,  3 ],
  [  3,  1,  2 ],
  [  2,  3,  1 ] ]

# doc/_Chapter_Direct_products_subalgebras_and_factor_algebras.xml:119-144
gap> Q := LoopByFunction([0..7],function(x,y) return (x+y) mod 8; end);;
gap> S := Subrightquasigroup( Q, [4] ); # inherits loop property from parent
<loop of size 2>
gap> [ IsSubrightquasigroup( Q, S ), IsSubquasigroup( Q, S ), IsSubloop( Q, S ) ];
[ true, true, true ]
gap> Elements( S ); # note indexing of elements here and below
[ l0, l4 ]
gap> Elements( S )[ 2 ]; # the 2nd element of S
l4
gap> S.2; # the 2nd element of Q, the parent of S
l1
gap> S[4]; # the element of parent Q corresponding to the given element of the underlying set
l4 
gap> Display( CayleyTable( S ) );
[ [  0,  4 ],
  [  4,  0 ] ]
gap> RightTranslation( Q, Q[4] ); # a permutation of the index set of Q
(1,5)(2,6)(3,7)(4,8)
gap> RightTranslation( S, S[4] ); # a permutation of the index set of S
(1,5)
gap> Subquasigroup( Q, [4] );
<loop of size 2>
gap> Subloop( Q, [4] );
<loop of size 2>

# doc/_Chapter_Direct_products_subalgebras_and_factor_algebras.xml:160-167
gap> AllSubloops( AsLoop( SymmetricGroup( 3 ) ) );
[ <associative loop of size 1>, <associative loop of size 2>, <associative loop of size 2>,
  <associative loop of size 3>, <associative loop of size 2>, <associative loop of size 6> ]
gap> P := ProjectionRightQuasigroup( [1..2] );; 
gap> AllSubrightquasigroups( P ); # every nonempty subset is a subrightquasigroup
[ <associative quandle of size 1>, <associative quandle of size 1>, <associative quandle of size 2> ]

# doc/_Chapter_Direct_products_subalgebras_and_factor_algebras.xml:198-207
gap> P := ProjectionRightQuasigroup( 3 ); # this is in fact an associative quandle
<associative quandle of size 3>
gap> S := Subrightquasigroup( P, [1,2] );
<associative quandle quasigroup of size 2>
gap> RightCosets( P, S ); # there is a single right coset of S in P
[ [ r1, r2 ] ]
gap> RightTransversal( P, S );
[ r1 ]

# doc/_Chapter_Direct_products_subalgebras_and_factor_algebras.xml:281-293
gap> P := ProjectionRightQuasigroup( 10 );;
gap> A := Subrightquasigroup( P, [1..4] );;
gap> B := Subrightquasigroup( P, [3..7] );;
gap> Intersection( A, B );
<associative quandle of size 2>
gap> Elements( last );
[ r3, r4 ]
gap> Join( A, B );
<associative quandle of size 7>
gap> Elements( last );
[ r1, r2, r3, r4, r5, r6, r7 ]

# doc/_Chapter_Direct_products_subalgebras_and_factor_algebras.xml:348-357
gap> Q := QuasigroupByFunction( [0..3], function(x,y) return (x-y) mod 4; end );;
gap> C := EquivalenceRelationByPartition( Q, [ [Q[0],Q[2]], [Q[1],Q[3]] ] );
<equivalence relation on <quasigroup of size 4 on 0, 1, 2, 3> >
gap> IsQuasigroupCongruence( C );
true
gap> D := EquivalenceRelationByPartition( Q, [ [Q[0],Q[1],Q[2]], [Q[3]] ] );;
gap> IsQuasigroupCongruence( D );
false

# doc/_Chapter_Direct_products_subalgebras_and_factor_algebras.xml:376-385
gap> Q := QuasigroupByFunction( GF(27), \- );
gap> C := QuasigroupCongruenceByPartition( Q, [ [ Q.1, Q.2, Q.3 ], [ Q.4, Q.5 ] ] );; merge Q.1, Q.2, Q.3 and also Q.4, Q.5
gap> List( EquivalenceClasses( C ), Size );
[ 9, 9, 9 ]
gap> G := AsLoop( SymmetricGroup( 5 ) );;
gap> C := LoopCongruenceByPartition( G, [ [ G[()], G[(1,2,3)] ] ] );; # merge (), (1,2,3)
gap> List( EquivalenceClasses( C ), Size );
[ 60, 60 ]

# doc/_Chapter_Direct_products_subalgebras_and_factor_algebras.xml:403-411
gap> Q := RightQuasigroupByFunction([0..7], function(x,y) return (x+2*y) mod 8; end );;
gap> C := RightQuasigroupCongruenceByPairs( Q, [ [ Q[0],Q[2] ] ] );; # merge 0, 2
gap> List( EquivalenceClasses( C ), Elements );
[ [ r0, r2, r4, r6 ], [ r1, r5 ], [ r3, r7 ] ]
gap> C := RightQuasigroupCongruenceByPairs( Q, [ [ Q[0],Q[2] ], [ Q[0], Q[1] ] ] );; # merge 0, 2 and also 0, 1
gap> List( EquivalenceClasses( C ), Elements );
[ [ r0, r1, r2, r3, r4, r5, r6, r7 ] ]

# doc/_Chapter_Direct_products_subalgebras_and_factor_algebras.xml:479-507
gap> # right quasigroup example
gap> R := RightQuasigroupByCayleyTable( [[2,2,1,1],[3,1,2,2],[4,3,3,3],[1,4,4,4]] );; 
gap> RMlt := RightMultiplicationGroup( R );
Group([ (1,2,3,4), (1,2) ])
gap> AllRightQuasigroupCongruences( R );
[ <equivalence relation on <right quasigroup of size 4 on 1, 2, 3, 4> >,
  <equivalence relation on <right quasigroup of size 4 on 1, 2, 3, 4> > ]
gap> IsSimpleRightQuasigroup( R ); # IsSimple( R ) is also supported
true
gap> # quasigroup example
gap> Q := QuasigroupByFunction( [0..3], function(x,y) return (x-y) mod 4; end );;
gap> congruences := AllQuasigroupCongruences( Q );;
gap> List( congruences, EquivalenceClasses );
[ [ {q0}, {q1}, {q2}, {q3} ], [ {q0}, {q1} ], [ {q0} ] ]
gap> List( EquivalenceClasses( congruences[ 2 ] ), Elements );
[ [ q0, q2 ], [ q1, q3 ] ]
gap> IsSimpleQuasigroup( Q ); # IsSimple( Q ) is also supported
false
gap> # loop example
gap> L := AsLoop( Group((1,2,3,4)) );;
gap> AllNormalSubloops( L );
[ <associative loop of size 1>, <associative loop of size 2>, <associative loop of size 4> ]
gap> IsSimpleLoop( L ); # IsSimple( L ) is also supported
false
gap> S := Subloop(  L, [ (1,3)(2,4) ] );;
gap> IsNormal( L, S );
true 

# doc/_Chapter_Direct_products_subalgebras_and_factor_algebras.xml:549-566
gap> Q := ProjectionRightQuasigroup( 6 );;
gap> C := EquivalenceRelationByPartition( Q, [[Q.1,Q.2],[Q.3,Q.4,Q.5],[Q.6]] );;
gap> [ IsRightQuasigroupCongruence( C ), IsQuasigroupCongruence( C ), IsLoopCongruence( C ) ];
[ true, false, false ]
gap> F := Q/C;
<associative quandle of size 3>
gap> Elements( F ); # the inner "r" comes from Q, the outer "r" from F.
[ r{r1}, r{r3}, r{r6} ]
gap> H := FactorRightQuasigroup( C, ConstructorStyle( false, false ) ); # non-index based version is supported (but not for /)
<associative quandle of size 3>
gap> HasMultiplicationTable( H );
false
gap> H.1*H.2;
r{r1}
gap> CayleyTable( H );
[ [ {r1}, {r1}, {r1} ], [ {r3}, {r3}, {r3} ], [ {r6}, {r6}, {r6} ] ]

# doc/_Chapter_Direct_products_subalgebras_and_factor_algebras.xml:579-612
gap> # auxiliary functions
gap> DotProduct := function( x, y ) return Sum( [1..Length(x)], i -> x[i]*y[i] ); end;;
gap> CrossProduct := function( x, y ) return [ x[2]*y[3]-x[3]*y[2], x[3]*y[1]-x[1]*y[3], x[1]*y[2]-x[2]*y[1] ]; end;;
gap> PaigeNorm := function( x ) return x[1]*x[8] - DotProduct( x{[2,3,4]},x{[5,6,7]} ); end;;
gap> PaigeMult := function( x, y )
> local a, b, c, d;
> a := x[1]*y[1] + DotProduct(x{[2,3,4]},y{[5,6,7]});
> b := x[1]*y{[2,3,4]} + x{[2,3,4]}*y[8] - CrossProduct(x{[5,6,7]},y{[5,6,7]});
> c := x{[5,6,7]}*y[1] + x[8]*y{[5,6,7]} + CrossProduct(x{[2,3,4]},y{[2,3,4]});
> d := DotProduct(x{[5,6,7]},y{[2,3,4]})+x[8]*y[8];
> return Concatenation( [a], b, c, [d] );
> end;;
gap> # Paige loop over GF(2) (index based approach in characteristic 2)
gap> F := GF(2);;
gap> S := Filtered( F^8, x -> PaigeNorm( x ) = One( F ) );;
gap> P := LoopByFunction( S, PaigeMult, ConstructorStyle( true, true ) ); 
<loop of size 120>
gap> # general approach (not index based, any characteristic, using congruences)
gap> n := 3;; # any prime power works but it will be very slow
gap> F := GF(n);;
gap> S := Filtered( F^8, x -> PaigeNorm( x ) = One( F ) );;
gap> M := LoopByFunction( S, PaigeMult, ConstructorStyle( false, false ) );;
gap> C := EquivalenceRelationByPartition( M, Set( S, x -> Set( [ M[x], M[-x] ] ) ) );; # factoring out +/- one
gap> P := FactorLoop( C, ConstructorStyle( false, false ) ); # 2000 ms
<loop of size 1080>
gap> # another approach using normal subloop
gap> n := 3;; F := GF(n);; S := Filtered( F^8, x -> PaigeNorm( x ) = One( F ) );;
gap> M := LoopByFunction( S, PaigeMult, ConstructorStyle( false, false ) );;
gap> one := [ Z(n)^0, 0*Z(n), 0*Z(n), 0*Z(n), 0*Z(n), 0*Z(n), 0*Z(n), Z(n)^0 ];;
gap> N := Subloop( M, [-one] );;
gap> P := FactorLoop( M, N, ConstructorStyle( false, false ) ); # 2000 ms, it takes a while to find the neutral element
<loop of size 1080>

#
gap> STOP_TEST("rightquasigroups03.tst", 1 );
