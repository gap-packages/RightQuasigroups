# RightQuasigroups, chapter 1
#
# DO NOT EDIT THIS FILE - EDIT EXAMPLES IN THE SOURCE INSTEAD!
#
# This file has been generated by AutoDoc. It contains examples extracted from
# the package documentation. Each example is preceded by a comment which gives
# the name of a GAPDoc XML file and a line range from which the example were
# taken. Note that the XML file in turn may have been generated by AutoDoc
# from some other input.
#
gap> START_TEST("rightquasigroups01.tst");

# doc/_Chapter_Introduction.xml:163-172
gap> Q := QuasigroupByCayleyTable( [[0,1],[1,0]] ); # declared quasigroup, in fact a group mathematically
<quasigroup of size 2>
gap> [ IsMagma( Q ), IsRightQuasigroup( Q ), IsQuasigroup( Q ), IsLoop( Q ), IsGroup( Q ) ];
[ true, true, true, false, false ]
gap> CategoryOfRightQuasigroup( Q );
<Category "IsQuasigroup">
gap> CategoryOfRightQuasigroup( [ Q, ProjectionRightQuasigroup( 5 ) ] ); # common category
<Category "IsRightQuasigroup">

# doc/_Chapter_Introduction.xml:196-211
gap> Q := QuasigroupByCayleyTable( [[0,1],[1,0]] );
<quasigroup of size 2>
gap> String( Q );
"<quasigroup of size 2>"
gap> IsAssociative( Q );
true
gap> Q;
<associative quasigroup of size 2>
gap> Display( Q );
<associative quasigroup of size 2 on 0, 1>
gap> Print( Q );
<associative quasigroup of size 2 on 0, 1>
gap> String( Q ); # was stored as attribute at first call
"<quasigroup of size 2>"

# doc/_Chapter_Introduction.xml:248-263
gap> Q := AsLoop( Group( (1,2) ) );
<associative loop of size 2>
gap> String( Q.1 );
"l()"
gap> Elements( Q );
[ l(), l(1,2) ]
gap> SetLoopElementsName( Q, "g" );; Elements( Q );
[ g(), g(1,2) ]
gap> String( Q.1 ); # dynamic since right quasigroup elements are not attribute storing
"g()"
gap> SetLoopElementsName( Q, "" );; Elements( Q ); # better legibility but perhaps confusing
[ (), (1,2) ]
gap> IsPerm( last[1] );
false

# doc/_Chapter_Introduction.xml:322-334
gap> Q := AsLoop( SymmetricGroup( 3 ) );;
gap> UnderlyingSetElm( Q.1 );
()
gap> UnderlyingSet( Q );
[ (), (2,3), (1,2), (1,2,3), (1,3,2), (1,3) ]
gap> ChangeUnderlyingSet( Q, ['a','b','c','d','e','f'] );
true
gap> UnderlyingSet( Q );
"abcdef"
gap> CayleyTable( Q );
[ "abcdef", "badcfe", "ceafbd", "dfbeac", "ecfadb", "fdebca" ]

# doc/_Chapter_Introduction.xml:460-487
gap> Q := RightQuasigroupByFunction( [0..3], function( x,y ) return (x+2*y) mod 4; end ); # index based by default
<right quasigroup of size 4>
gap> UnderlyingSet( Q );
[ 0, 1, 2, 3 ]
gap> Elements( Q ); # default prefix "r" is assigned to right quasigroup elements
[ r0, r1, r2, r3 ]
gap> [ Elements(Q)[1], Q.1, Q[0] ]; # three ways of accessing elements
[ r0, r0, r0 ]
gap> Display( CayleyTable( Q ) ); # based on the underlying set
[ [  0,  2,  0,  2 ],
  [  1,  3,  1,  3 ],
  [  2,  0,  2,  0 ],
  [  3,  1,  3,  1 ] ]
gap> Display( MultiplicationTable( Q ) ); # based on [1..n], here [1..4]
[ [  1,  3,  1,  3 ],
  [  2,  4,  2,  4 ],
  [  3,  1,  3,  1 ],
  [  4,  2,  4,  2 ] ]
gap> mult := MultiplicationFunction( Q ); # based on [1..n] since Q is index based
function( i, j ) ... end
gap> mult( 1, 1 );
1
gap> Q[0]*Q[1];
r2
gap> Q[0]/Q[1]; # RightQuotient and RightDivision are also supported
r2

# doc/_Chapter_Introduction.xml:498-515
gap> Q := AsLoop( SymmetricGroup( 3 ), ConstructorStyle( false, false ) ); # not index based, arguments not checked
<associative loop of size 6>
gap> UnderlyingSet( Q );
[ (), (2,3), (1,2), (1,2,3), (1,3,2), (1,3) ]
gap> Elements( Q ); # default prefix "l" is assigned to loop elements
[ l(), l(2,3), l(1,2), l(1,2,3), l(1,3,2), l(1,3) ]
gap> mult := MultiplicationFunction( Q ); # based on the underlying set since Q is not index based
<Operation "*">
gap> mult( (1,2), (1,3) );
(1,2,3)
gap> One( Q );
l()
gap> Commutator( Q[(1,2)], Q[(1,3)] );
l(1,3,2)
gap> Associator( Q[(1,2)], Q[(1,3)], Q[(2,3)] );
l()

# doc/_Chapter_Introduction.xml:541-564
gap> Q := RightQuasigroupByFunction([0..5], function(x,y) return (x+y) mod 6; end );; Elements( Q ); 
[ r0, r1, r2, r3, r4, r5 ]
gap> A := Subrightquasigroup( Q, [2] );
<right quasigroup of size 3>
gap> Elements( A );
[ r0, r2, r4 ]
gap> Parent( A ) = Q;
true
gap> Elements( A )[ 3 ]; # the 3rd element of A
r4
gap> A.3; # the 3rd element of the parent of A
r2
gap> A[4]; # the element of the parent of A corresponding to the given underlying element
r4
gap> Display( CayleyTable( A ) );
[ [  0,  2,  4 ],
  [  2,  4,  0 ],
  [  4,  0,  2 ] ]
gap> Display( MultiplicationTable( A ) );
[ [  1,  2,  3 ],
  [  2,  3,  1 ],
  [  3,  1,  2 ] ]

# doc/_Chapter_Introduction.xml:674-699
gap> Q := RightQuasigroupByFunction( GF( 9 ), \+, ConstructorStyle( false, false ) ); # not index based, arguments not checked
<right quasigroup of size 9>
gap> IsIndexBased( Q );
false
gap> x := Q.2;
rZ(3)^0
gap> x![1]; # the underlying element
Z(3)^0
gap> x*x;
rZ(3)
gap> F := FamilyObj( x );
<Family: "RightQuasigroupFam">
gap> [ IsBound( F!.mult ), IsBound( F!.rdiv ), IsBound( F!.ldiv ) ]; # no left division in a right quasigroup
[ true, true, false ]
gap> [ IsBound( F!.multTable ), IsBound( F!.rdivTable ), IsBound( F!.ldivTable ) ]; # no tables are bound
[ false, false, false ]
gap> mult := MultiplicationFunction( Q );
<Operation "+">
gap> mult( Z(3), Z(3) );
Z(3)^0
gap> rdiv := RightDivisionFunction( Q ); # the constructor does not know that this really is <Operation "-">
function( x, y ) ... end
gap> rdiv( Z(3), Z(3) );
0*Z(3)

# doc/_Chapter_Introduction.xml:703-735
gap> Q := RightQuasigroupByFunction( GF( 9 ), \+, ConstructorStyle( false, false ) );; # same as in the above example, not index based
gap> R := IndexBasedCopy( Q );;
gap> IsIndexBased( R );
true
gap> UnderlyingSet( R ); # no change to the underlying set
[ 0*Z(3), Z(3)^0, Z(3), Z(3^2), Z(3^2)^2, Z(3^2)^3, Z(3^2)^5, Z(3^2)^6, 
  Z(3^2)^7 ]
gap> IsCanonical( R ); # underlying set is not [1..n]
false
gap> x := R.2;;
gap> x![1]; # the index of x in the parent of R (here R itself)
2
gap> x*x;
rZ(3)
gap> F := FamilyObj( R.1 );;
gap> [ IsBound( F!.mult ), IsBound( F!.rdiv ), IsBound( F!.ldiv ) ]; # if bound then based on respective tables
[ true, true, false ]
gap> [ IsBound( F!.multTable ), IsBound( F!.rdivTable ), IsBound( F!.ldivTable ) ]; # division tables will be bound when divisions are called 
[ true, false, false ]
gap> x/x;
r0*Z(3)
gap> IsBound( F!.rdivTable );
true
gap> mult := MultiplicationFunction( R ); # the multiplication function is based on indices
function( i, j ) ... end
gap> mult( 1, 1 );
1
gap> C := CanonicalCopy( Q );
<right quasigroup of size 9>
gap> UnderlyingSet( C ); # underlying set has changed to [1..n]
[ 1, 2, 3, 4, 5, 6, 7, 8, 9 ]

# doc/_Chapter_Introduction.xml:781-794
gap> Q := AsLoop( GF(8) );;
gap> GeneratorsOfLoop( Q ); # trivial generating set
[ l0*Z(2), lZ(2)^0, lZ(2^3), lZ(2^3)^2, lZ(2^3)^3, lZ(2^3)^4, lZ(2^3)^5, 
  lZ(2^3)^6 ]
gap> GeneratorsSmallest( Q ); # with respect to lexicographic ordering
[ lZ(2^3)^4, lZ(2^3)^5, lZ(2^3)^6 ]
gap> GeneratorsOfLoop( Q ); # changed since a smaller generating set has been found
[ lZ(2^3)^4, lZ(2^3)^5, lZ(2^3)^6 ]
gap> SmallGeneratingSet( Q ); # with respect to greedy algorithm
[ lZ(2)^0, lZ(2^3), lZ(2^3)^2 ]
gap> GeneratorsOfLoop( Q ); # not changed since no smaller generating set has been found
[ lZ(2^3)^4, lZ(2^3)^5, lZ(2^3)^6 ]

#
gap> STOP_TEST("rightquasigroups01.tst", 1);
