# RightQuasigroups, chapter 4
#
# DO NOT EDIT THIS FILE - EDIT EXAMPLES IN THE SOURCE INSTEAD!
#
# This file has been generated by AutoDoc. It contains examples extracted from
# the package documentation. Each example is preceded by a comment which gives
# the name of a GAPDoc XML file and a line range from which the example were
# taken. Note that the XML file in turn may have been generated by AutoDoc
# from some other input.
#
gap> START_TEST( "rightquasigroups04.tst");

# doc/_Chapter_Mappings.xml:65-73
gap> Q := MoufangLoop( 12, 1 );;
gap> m := MappingByFunction( Q, Q, x -> x*x );
MappingByFunction( <Moufang loop 12/1>, <Moufang loop 12/1>, function( x ) ... end )
gap> [ Source( m ) = Q, Range( m ) = Q ];
[ true, true ]
gap> Q.2*Q.2 = Q.2^m;
true

# doc/_Chapter_Mappings.xml:132-148
gap> Q := MoufangLoop( 12, 1 );; S := Subloop( Q, [Q.3] );;
gap> ParentInd( S );
[ 1, 3, 5 ]
gap> (Q.3)^(3,4) = Q.4;
true
gap> IsParentPerm( S, (3,4) ); # does not act on [ 1, 3, 5 ] 
false
gap> IsParentPerm( S, (3,5) ); # acts on [ 1, 3, 5 ]
true
gap> IsParentPerm( S, (3,5)(7,8) ); # action on the complement of S is ignored
true
gap> IsCanonicalPerm( S, (1,2,3) ); # acts on [1..Size(S)]
true
gap> IsCanonicalPerm( S, (1,3,5) ); # does not act on [1..Size(S)]
false

# doc/_Chapter_Mappings.xml:181-198
gap> Q := MoufangLoop( 12, 1 );; S := Subloop( Q, [Q.3] );; ParentInd( S );
[ 1, 3, 5 ]
gap> m := AsRightQuasigroupMapping( S, (1,3,5) );
MappingByFunction( <Moufang loop of size 3>, <Moufang loop of size 3>, function( x ) ... end )
gap> m2 := AsRightQuasigroupMapping( S, (1,2,3), true ); # argument is a canonical permutation
MappingByFunction( <Moufang loop of size 3>, <Moufang loop of size 3>, function( x ) ... end )
gap> m = m2;
true
gap> f := AsParentPerm( m ); # ParentInd( m ) has the same effect
(1,3,5)
gap> f2 := AsCanonicalPerm( m );
(1,2,3)
gap> AsParentPerm( S, f2 );
(1,3,5)
gap> AsCanonicalPerm( S, f );
(1,2,3)

# doc/_Chapter_Mappings.xml:258-276
gap> Q := AsLoop( SymmetricGroup( 4 ) );;
gap> S1 := Subloop( Q, [ Q[(1,2,3)] ] );;
gap> S2 := Subloop( Q, [ Q[(1,4)]*Q[(1,2,3)]*Q[(1,4)] ] );; # conjugate subloop
gap> m := MappingByFunction( S1, S2, x-> Q[(1,4)]*x*Q[(1,4)] ); # conjugation S1 -> S2
MappingByFunction( <associative loop of size 3>, <associative loop of size 3>, function( x ) ... end )
gap> ParentInd( S1 );
[ 1, 9, 13 ]
gap> ParentInd( S2 );
[ 1, 4, 5 ]
gap> t := AsParentTransformation( m ); 
Transformation( [ 1, 2, 3, 4, 5, 6, 7, 8, 4, 10, 11, 12, 5 ] )
gap> IsParentTransformation( S1, S2, t );
true
gap> AsCanonicalTransformation( m );
IdentityTransformation
gap> IsCanonicalTransformation( S1, S2, last );
true

#
gap> STOP_TEST("rightquasigroups04.tst", 1 );
