# RightQuasigroups, chapter 2
#
# DO NOT EDIT THIS FILE - EDIT EXAMPLES IN THE SOURCE INSTEAD!
#
# This file has been generated by AutoDoc. It contains examples extracted from
# the package documentation. Each example is preceded by a comment which gives
# the name of a GAPDoc XML file and a line range from which the example were
# taken. Note that the XML file in turn may have been generated by AutoDoc
# from some other input.
#
gap> START_TEST( "rightquasigroups02.tst");

# doc/_Chapter_Constructors.xml:94-118
gap> M := MagmaByMultiplicationTable( [ [1,1], [2,2] ] );;
gap> Elements( M );
[ m1, m2 ]
gap> IsRightQuasigroupMagma( M );
true
gap> R := AsRightQuasigroup( M );
<right quasigroup of size 2>
gap> Elements( R );
[ rm1, rm2 ]
gap> IsQuasigroupMagma( R ); # synonym of IsLatinMagma
false
gap> AsQuasigroup( M ); # arguments of constructors are by default not checked!
<quasigroup of size 2>
gap> AsQuasigroup( M, rec( checkArguments := true ) ); # the optional argument will force a check
fail
gap> G := Group((1,2,3));; IsLoopMagma( G );
true
gap> L := AsLoop( G ); # multiplicative group
<associative loop of size 3>
gap> Elements( L );
[ l(), l(1,2,3), l(1,3,2) ]
gap> AsRightQuasigroup(GF(7)^2); # additive group
<associative right quasigroup of size 49>

# doc/_Chapter_Constructors.xml:162-177
gap> Q := RQ_AlgebraShell( IsRightQuasigroup, GF(5), rec( indexBased := false ) );
<right quasigroup shell of size 5>
gap> F := FamilyObj( Q.1 );;
gap> F!.mult := function(x,y) return x+y; end;;
gap> Q; # still a shell since right division is not bound
<right quasigroup shell of size 5>
gap> Q.1*Q.1; # multiplication already works since Q is not index based and F!.mult is bound
r0*Z(5)
gap> RQ_AddDefaultOperations( Q );
true
gap> Q; # all needed operations for the right quasigroup are now bound
<right quasigroup of size 5>
gap> Q.1/Q.1;
r0*Z(5)

# doc/_Chapter_Constructors.xml:181-196
gap> Q := RQ_AlgebraShell( IsRightQuasigroup, GF(5) );
<right quasigroup shell of size 5>
gap> F := FamilyObj( Q.1 );;
gap> F!.multTable := List( GF(5), x-> List( GF(5), y -> Position( Elements(GF(5)), x+y ) ) );;
gap> Q; # still a shell since right division is not bound
<right quasigroup shell of size 5>
gap> Q.1*Q.1; # multiplication already works since Q is index based and F!.multTable is bound
r0*Z(5)
gap> RQ_AddDefaultOperations( Q );
true
gap> Q; # all needed operations for the right quasigroup are now bound
<right quasigroup of size 5>
gap> Q.1/Q.1;
r0*Z(5)

# doc/_Chapter_Constructors.xml:291-298
gap> ct := [[1,1],[0,0]];;
gap> NormalizedRightQuasigroupCayleyTable( ct );
[ [ 0, 0 ], [ 1, 1 ] ]
gap> ct := [["b","a"],["a","b"]];;
gap> NormalizedQuasigroupCayleyTable( ct );
[ [ "a", "b" ], [ "b", "a" ] ]

# doc/_Chapter_Constructors.xml:314-341
gap> ct := [ [ "red", "white", "white" ], [ "blue", "blue", "red" ], [ "white", "red", "blue" ] ];;
gap> IsRightQuasigroupCayleyTable( ct );
true
gap> Q := RightQuasigroupByCayleyTable( ct );
<right quasigroup of size 3>
gap> Display( MultiplicationTable( Q ) ); # note the ordering of elements, with rows and columns implicitly labeled 1, 2, 3
[ [  2,  3,  3 ],
  [  1,  1,  2 ],
  [  3,  2,  1 ] ]
gap> PrintArray( CayleyTable( Q ) );
[ [    red,  white,  white ],
  [   blue,   blue,    red ],
  [  white,    red,   blue ] ]
gap> Elements( Q );
[ rblue, rred, rwhite ]
gap> IsQuasigroupCayleyTable( ct );
false
gap> ct2 := [ [0,1],[1,0] ];;
gap> [ IsQuasigroupCayleyTable(ct2), IsLoopCayleyTable(ct2) ];
[ true, true ]
gap> QuasigroupByCayleyTable(ct2);
<quasigroup of size 2>
gap> LoopByCayleyTable(ct2);
<loop of size 2>
gap> One(last);
l0

# doc/_Chapter_Constructors.xml:415-422
gap> mult := function( x, y ) return (x+2*y) mod 4; end;
function( x, y ) ... end
gap> IsRightQuasigroupFunction( [0..3], mult );
true
gap> IsQuasigroupFunction( [0..3], mult );
false

# doc/_Chapter_Constructors.xml:439-458
gap> mult := \+;;
gap> rdiv := \-;;
gap> ldiv := function( x,y ) return -x+y; end;;
gap> one := Zero( GF(5) );;
gap> IsLoopFunction( GF(5), mult ); 
true
gap> IsLoopFunction( GF(5), mult, rdiv );
true
gap> IsLoopFunction( GF(5), mult, rdiv, ldiv );
true
gap> IsLoopFunction( GF(5), mult, one );
true
gap> IsLoopFunction( GF(5), mult, rdiv, one );
true
gap> IsLoopFunction( GF(5), mult, rdiv, ldiv, one );
true
gap> IsLoopFunction( GF(5), mult, ldiv ); # returns false because right division is expected before left division
false

# doc/_Chapter_Constructors.xml:500-509
gap> S := GF(5);;
gap> mult := function( x, y ) return x+2*y; end;;
gap> rdiv := function( x, y ) return x-2*y; end;;
gap> ldiv := function( x, y ) return (y-x)/2; end;;
gap> IsQuasigroupFunction( S, mult, rdiv, ldiv );
true
gap> QuasigroupByFunction( S, mult, rdiv, ldiv );
<quasigroup of size 5>

# doc/_Chapter_Constructors.xml:526-539
gap> p := 1000003;;
gap> S := Difference( GF(p), [ Zero( GF( p ) ) ] );; # nonzero elements of GF(p)
gap> Q := LoopByFunction( S, \*, ConstructorStyle( false, false ) ); # not index based, no arguments checked
<loop of size 1000002>
gap> One( Q );
lZmodpZObj( 1, 1000003 )
gap> Q.10*Q.100;
lZmodpZObj( 1000, 1000003 )
gap> Q.100/Q.10;
lZmodpZObj( 10, 1000003 )
gap> Inverse( Q.10 );
lZmodpZObj( 300001, 1000003 )

# doc/_Chapter_Constructors.xml:589-607
gap> section := [ (), (1,2,3,4), (), (1,3)(2,4) ];;
gap> IsRightSection( [1..4], section );
true
gap> IsRightSection( section ); # the underlying set can be omitted
true
gap> IsRightSection( "abcd", section ); # implicit permutation action on the set ['a','b','c','d']
true
gap> IsQuasigroupRightSection( [1..4], section );
false
gap> Q := RightQuasigroupByRightSection( section ); # the underlying set can be omitted
<right quasigroup of size 4>
gap> Q[3]*Q[2];
r4
gap> RightQuasigroupByRightSection( "abcd", section );
<right quasigroup of size 4>
gap> Elements( last );
[ r'a', r'b', r'c', r'd' ]

# doc/_Chapter_Constructors.xml:612-622
gap> i := Z(2)*[[1,0],[0,1]];;
gap> m := Z(2)*[[1,1],[0,1]];;
gap> section := [m,m,i,i];;
gap> IsRightSection( GF(2)^2, section );
true
gap> Q := RightQuasigroupByRightSection( GF(2)^2, section );
<right quasigroup of size 4>
gap> Q.1;
r[ 0*Z(2), 0*Z(2) ]

# doc/_Chapter_Constructors.xml:627-639
gap> section := [(1,2),()];;
gap> IsQuasigroupRightSection( [1,2], section );
true
gap> QuasigroupByRightSection( [1,2], section );
<quasigroup of size 2>
gap> IsLoopRightSection( [1,2], section );
true
gap> LoopByRightSection( [1,2], section );
<loop of size 2>
gap> One( last );
l2

# doc/_Chapter_Constructors.xml:700-718
gap> G := SymmetricGroup( 5 );;
gap> H := Subgroup( G, [ (1,2),(1,3) ] );;
gap> T := RightTransversal( G, H );;
gap> [ IsRightFolder( T ), IsRightFolder( G, H, T ) ];
[ true, true ]
gap> Q1 := RightQuasigroupByRightFolder( T );
<right quasigroup of size 20>
gap> Q2 := RightQuasigroupByRightFolder( G, H, T );
<right quasigroup of size 20>
gap> Q3 := RightQuasigroupByRightFolder( G, H, Elements( T ) );
<right quasigroup of size 20>
gap> AsCanonicalPerm( IsomorphismRightQuasigroups( Q1, Q2 ) );
()
gap> UnderlyingSet( Q1 ) = Elements( T );
true
gap> IsQuasigroupRightFolder( T );
false

# doc/_Chapter_Constructors.xml:722-736
gap> G := SymmetricGroup( 2 );;
gap> H := Subgroup( G, [()] );;
gap> T := RightTransversal( G, H );;
gap> IsQuasigroupRightFolder( T );
true
gap> IsLoopRightFolder( T );
true
gap> QuasigroupByRightFolder( T );
<quasigroup of size 2>
gap> LoopByRightFolder( T );
<loop of size 2>
gap> Elements( last );
[ l(), l(1,2) ]

# doc/_Chapter_Constructors.xml:757-762
gap> ProjectionRightQuasigroup( [1..1000], rec( indexBased := false ) );; # 16 ms to construct, 
gap> Q := ProjectionRightQuasigroup( [1..1000] );; # 375 ms to construct
gap> Q.123*Q.456;
r123

# doc/_Chapter_Constructors.xml:808-815
gap> RandomRightQuasigroup( 4 );
<right quasigroup of size 4>
gap> Elements( RandomQuasigroup( ["a","b","c"] ) );
[ qa, qb, qc ]
gap> RandomLoop( ["a","b","c"] );
<loop of size 3>

#
gap> STOP_TEST("rightquasigroups02.tst", 1 );
