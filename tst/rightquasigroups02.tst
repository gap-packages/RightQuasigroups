# RightQuasigroups, chapter 2
#
# DO NOT EDIT THIS FILE - EDIT EXAMPLES IN THE SOURCE INSTEAD!
#
# This file has been generated by AutoDoc. It contains examples extracted from
# the package documentation. Each example is preceded by a comment which gives
# the name of a GAPDoc XML file and a line range from which the example were
# taken. Note that the XML file in turn may have been generated by AutoDoc
# from some other input.
#
gap> START_TEST("rightquasigroups02.tst");

# doc/_Chapter_Constructors.xml:93-117
gap> M := MagmaByMultiplicationTable( [ [1,1], [2,2] ] );;
gap> Elements( M );
[ m1, m2 ]
gap> IsRightQuasigroupMagma( M );
true
gap> R := AsRightQuasigroup( M );
<right quasigroup of size 2>
gap> Elements( R );
[ rm1, rm2 ]
gap> IsQuasigroupMagma( R ); # synonym of IsLatinMagma
false
gap> AsQuasigroup( M ); # arguments of constructors are by default not checked!
<quasigroup of size 2>
gap> AsQuasigroup( M, rec( checkArguments := true ) ); # the optional argument will force a check
fail
gap> G := Group((1,2,3));; IsLoopMagma( G );
true
gap> L := AsLoop( G ); # multiplicative group
<associative loop of size 3>
gap> Elements( L );
[ l(), l(1,2,3), l(1,3,2) ]
gap> AsRightQuasigroup(GF(7)^2); # additive group
<associative right quasigroup of size 49>

# doc/_Chapter_Constructors.xml:161-176
gap> Q := RQ_AlgebraShell( IsRightQuasigroup, GF(5), rec( indexBased := false ) );
<right quasigroup shell of size 5>
gap> F := FamilyObj( Q.1 );;
gap> F!.mult := function(x,y) return x+y; end;;
gap> Q; # still a shell since right division is not bound
<right quasigroup shell of size 5>
gap> Q.1*Q.1; # multiplication already works since Q is not index based and F!.mult is bound
r0*Z(5)
gap> RQ_AddDefaultOperations( Q );
true
gap> Q; # all needed operations for the right quasigroup are now bound
<right quasigroup of size 5>
gap> Q.1/Q.1;
r0*Z(5)

# doc/_Chapter_Constructors.xml:180-195
gap> Q := RQ_AlgebraShell( IsRightQuasigroup, GF(5) );
<right quasigroup shell of size 5>
gap> F := FamilyObj( Q.1 );;
gap> F!.multTable := List( GF(5), x-> List( GF(5), y -> Position( Elements(GF(5)), x+y ) ) );;
gap> Q; # still a shell since right division is not bound
<right quasigroup shell of size 5>
gap> Q.1*Q.1; # multiplication already works since Q is index based and F!.multTable is bound
r0*Z(5)
gap> RQ_AddDefaultOperations( Q );
true
gap> Q; # all needed operations for the right quasigroup are now bound
<right quasigroup of size 5>
gap> Q.1/Q.1;
r0*Z(5)

# doc/_Chapter_Constructors.xml:290-297
gap> ct := [[1,1],[0,0]];;
gap> NormalizedRightQuasigroupCayleyTable( ct );
[ [ 0, 0 ], [ 1, 1 ] ]
gap> ct := [["b","a"],["a","b"]];;
gap> NormalizedQuasigroupCayleyTable( ct );
[ [ "a", "b" ], [ "b", "a" ] ]

# doc/_Chapter_Constructors.xml:313-340
gap> ct := [ [ "red", "white", "white" ], [ "blue", "blue", "red" ], [ "white", "red", "blue" ] ];;
gap> IsRightQuasigroupCayleyTable( ct );
true
gap> Q := RightQuasigroupByCayleyTable( ct );
<right quasigroup of size 3>
gap> Elements( Q ); # note the ordering of the elements induced by "blue" < "red" < "white"
[ rblue, rred, rwhite ]
gap> PrintArray( CayleyTable( Q ) ); # rows and column are implicitly labeled "blue", "red", "white"
[ [    red,  white,  white ],
  [   blue,   blue,    red ],
  [  white,    red,   blue ] ]
gap> Display( MultiplicationTable( Q ) ); # rows and columns are implicitly labeled 1, 2, 3
[ [  2,  3,  3 ],
  [  1,  1,  2 ],
  [  3,  2,  1 ] ]
gap> IsQuasigroupCayleyTable( ct );
false
gap> t := [ [0,1], [1,0] ];;
gap> [ IsQuasigroupCayleyTable( t ), IsLoopCayleyTable( t ) ];
[ true, true ]
gap> QuasigroupByCayleyTable( t );
<quasigroup of size 2>
gap> LoopByCayleyTable( t );
<loop of size 2>
gap> One( last );
l0

# doc/_Chapter_Constructors.xml:414-421
gap> mult := function( x, y ) return (x+2*y) mod 4; end;
function( x, y ) ... end
gap> IsRightQuasigroupFunction( [0..3], mult );
true
gap> IsQuasigroupFunction( [0..3], mult );
false

# doc/_Chapter_Constructors.xml:438-457
gap> mult := \+;;
gap> rdiv := \-;;
gap> ldiv := function( x,y ) return -x+y; end;;
gap> one := Zero( GF(5) );;
gap> IsLoopFunction( GF(5), mult ); 
true
gap> IsLoopFunction( GF(5), mult, rdiv );
true
gap> IsLoopFunction( GF(5), mult, rdiv, ldiv );
true
gap> IsLoopFunction( GF(5), mult, one );
true
gap> IsLoopFunction( GF(5), mult, rdiv, one );
true
gap> IsLoopFunction( GF(5), mult, rdiv, ldiv, one );
true
gap> IsLoopFunction( GF(5), mult, ldiv ); # returns false because right division is expected before left division
false

# doc/_Chapter_Constructors.xml:499-512
gap> S := GF(5);;
gap> mult := function( x, y ) return x+2*y; end;;
gap> IsQuasigroupFunction( S, mult );
true
gap> QuasigroupByFunction( S, mult ); # it is not necessary to provide right division and left division
<quasigroup of size 5>
gap> rdiv := function( x, y ) return x-2*y; end;;
gap> ldiv := function( x, y ) return (y-x)/2; end;;
gap> IsQuasigroupFunction( S, mult, rdiv, ldiv ); 
true
gap> QuasigroupByFunction( S, mult, rdiv, ldiv ); # but calculations will be faster if the divisions are provided
<quasigroup of size 5>

# doc/_Chapter_Constructors.xml:529-542
gap> p := 1000003;;
gap> S := Difference( GF(p), [ Zero( GF( p ) ) ] );; # nonzero elements of GF(p)
gap> Q := LoopByFunction( S, \*, ConstructorStyle( false, false ) ); # not index based, no arguments checked
<loop of size 1000002>
gap> One( Q );
lZmodpZObj( 1, 1000003 )
gap> Q.10*Q.100;
lZmodpZObj( 1000, 1000003 )
gap> Q.100/Q.10;
lZmodpZObj( 10, 1000003 )
gap> Inverse( Q.10 );
lZmodpZObj( 300001, 1000003 )

# doc/_Chapter_Constructors.xml:592-610
gap> section := [ (), (1,2,3,4), (), (1,3)(2,4) ];;
gap> IsRightSection( [1..4], section );
true
gap> IsRightSection( section ); # the underlying set can be omitted
true
gap> IsRightSection( "abcd", section ); # implicit permutation action on the set ['a','b','c','d']
true
gap> IsQuasigroupRightSection( [1..4], section );
false
gap> Q := RightQuasigroupByRightSection( section ); # the underlying set can be omitted
<right quasigroup of size 4>
gap> Q[3]*Q[2];
r4
gap> RightQuasigroupByRightSection( "abcd", section );
<right quasigroup of size 4>
gap> Elements( last );
[ r'a', r'b', r'c', r'd' ]

# doc/_Chapter_Constructors.xml:615-625
gap> i := Z(2)*[[1,0],[0,1]];;
gap> m := Z(2)*[[1,1],[0,1]];;
gap> section := [m,m,i,i];;
gap> IsRightSection( GF(2)^2, section );
true
gap> Q := RightQuasigroupByRightSection( GF(2)^2, section );
<right quasigroup of size 4>
gap> Q.1;
r[ 0*Z(2), 0*Z(2) ]

# doc/_Chapter_Constructors.xml:630-642
gap> section := [(1,2),()];;
gap> IsQuasigroupRightSection( [1,2], section );
true
gap> QuasigroupByRightSection( [1,2], section );
<quasigroup of size 2>
gap> IsLoopRightSection( [1,2], section );
true
gap> LoopByRightSection( [1,2], section );
<loop of size 2>
gap> One( last );
l2

# doc/_Chapter_Constructors.xml:703-721
gap> G := SymmetricGroup( 5 );;
gap> H := Subgroup( G, [ (1,2),(1,3) ] );;
gap> T := RightTransversal( G, H );;
gap> [ IsRightFolder( T ), IsRightFolder( G, H, T ) ];
[ true, true ]
gap> Q1 := RightQuasigroupByRightFolder( T );
<right quasigroup of size 20>
gap> Q2 := RightQuasigroupByRightFolder( G, H, T );
<right quasigroup of size 20>
gap> Q3 := RightQuasigroupByRightFolder( G, H, Elements( T ) );
<right quasigroup of size 20>
gap> AsCanonicalPerm( IsomorphismRightQuasigroups( Q1, Q2 ) );
()
gap> UnderlyingSet( Q1 ) = Elements( T );
true
gap> IsQuasigroupRightFolder( T );
false

# doc/_Chapter_Constructors.xml:725-739
gap> G := SymmetricGroup( 2 );;
gap> H := Subgroup( G, [()] );;
gap> T := RightTransversal( G, H );;
gap> IsQuasigroupRightFolder( T );
true
gap> IsLoopRightFolder( T );
true
gap> QuasigroupByRightFolder( T );
<quasigroup of size 2>
gap> LoopByRightFolder( T );
<loop of size 2>
gap> Elements( last );
[ l(), l(1,2) ]

# doc/_Chapter_Constructors.xml:760-765
gap> ProjectionRightQuasigroup( [1..1000], rec( indexBased := false ) );; # 16 ms to construct, 
gap> Q := ProjectionRightQuasigroup( [1..1000] );; # 375 ms to construct
gap> Q.123*Q.456;
r123

# doc/_Chapter_Constructors.xml:811-818
gap> RandomRightQuasigroup( 4 );
<right quasigroup of size 4>
gap> Elements( RandomQuasigroup( ["a","b","c"] ) );
[ qa, qb, qc ]
gap> RandomLoop( ["a","b","c"] );
<loop of size 3>

#
gap> STOP_TEST("rightquasigroups02.tst", 1);
